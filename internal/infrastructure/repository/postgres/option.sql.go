// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: option.sql

package postgres

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createTempTableOptionValues = `-- name: CreateTempTableOptionValues :exec
CREATE TEMPORARY TABLE temp_option_values (
  id UUID PRIMARY KEY,
  value TEXT NOT NULL,
  option_id UUID NOT NULL,
  deleted_at TIMESTAMP
) ON COMMIT DROP
`

func (q *Queries) CreateTempTableOptionValues(ctx context.Context) error {
	_, err := q.db.Exec(ctx, createTempTableOptionValues)
	return err
}

const createTempTableOptionValuesProductVariants = `-- name: CreateTempTableOptionValuesProductVariants :exec
CREATE TEMPORARY TABLE temp_option_values_product_variants (
  product_variant_id UUID NOT NULL,
  option_value_id UUID NOT NULL,
  PRIMARY KEY (product_variant_id, option_value_id)
) ON COMMIT DROP
`

func (q *Queries) CreateTempTableOptionValuesProductVariants(ctx context.Context) error {
	_, err := q.db.Exec(ctx, createTempTableOptionValuesProductVariants)
	return err
}

const getOption = `-- name: GetOption :one
SELECT
  id, name, product_id, deleted_at
FROM
  options
WHERE
  id = $1::uuid
  AND CASE
    WHEN $2::text = 'exclude' THEN deleted_at IS NULL
    WHEN $2::text = 'only' THEN deleted_at IS NOT NULL
    WHEN $2::text = 'all' THEN TRUE
    ELSE deleted_at IS NULL
  END
`

type GetOptionParams struct {
	ID      uuid.UUID
	Deleted string
}

func (q *Queries) GetOption(ctx context.Context, arg GetOptionParams) (Option, error) {
	row := q.db.QueryRow(ctx, getOption, arg.ID, arg.Deleted)
	var i Option
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ProductID,
		&i.DeletedAt,
	)
	return i, err
}

type InsertTempTableOptionValuesParams struct {
	ID        uuid.UUID
	Value     string
	OptionID  uuid.UUID
	DeletedAt pgtype.Timestamp
}

type InsertTempTableOptionValuesProductVariantsParams struct {
	ProductVariantID uuid.UUID
	OptionValueID    uuid.UUID
}

const listOptionValues = `-- name: ListOptionValues :many
SELECT
  id, value, deleted_at, option_id
FROM
  option_values
WHERE
  CASE
    WHEN $1::uuid IS NULL THEN TRUE
    ELSE option_values.id = $1::uuid
  END
  AND CASE
    WHEN $2::uuid[] IS NULL THEN TRUE
    WHEN cardinality($2::uuid[]) = 0 THEN TRUE
    ELSE option_values.option_id = ANY ($2::uuid[])
  END
  AND CASE
    WHEN $3::text = 'exclude' THEN deleted_at IS NULL
    WHEN $3::text = 'only' THEN deleted_at IS NOT NULL
    WHEN $3::text = 'all' THEN TRUE
    ELSE deleted_at IS NULL
  END
ORDER BY
  option_values.id
`

type ListOptionValuesParams struct {
	ID        pgtype.UUID
	OptionIds []uuid.UUID
	Deleted   string
}

func (q *Queries) ListOptionValues(ctx context.Context, arg ListOptionValuesParams) ([]OptionValue, error) {
	rows, err := q.db.Query(ctx, listOptionValues, arg.ID, arg.OptionIds, arg.Deleted)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OptionValue
	for rows.Next() {
		var i OptionValue
		if err := rows.Scan(
			&i.ID,
			&i.Value,
			&i.DeletedAt,
			&i.OptionID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOptionValuesProductVariants = `-- name: ListOptionValuesProductVariants :many
SELECT
  product_variant_id, option_value_id
FROM
  option_values_product_variants
WHERE
  CASE
    WHEN $1::uuid[] IS NULL THEN TRUE
    WHEN cardinality($1::uuid[]) = 0 THEN TRUE
    ELSE option_values_product_variants.option_value_id = ANY ($1::uuid[])
  END
  AND CASE
    WHEN $2::uuid[] IS NULL THEN TRUE
    WHEN cardinality($2::uuid[]) = 0 THEN TRUE
    ELSE option_values_product_variants.product_variant_id = ANY ($2::uuid[])
  END
`

type ListOptionValuesProductVariantsParams struct {
	OptionValueIDs    []uuid.UUID
	ProductVariantIDs []uuid.UUID
}

func (q *Queries) ListOptionValuesProductVariants(ctx context.Context, arg ListOptionValuesProductVariantsParams) ([]OptionValuesProductVariant, error) {
	rows, err := q.db.Query(ctx, listOptionValuesProductVariants, arg.OptionValueIDs, arg.ProductVariantIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OptionValuesProductVariant
	for rows.Next() {
		var i OptionValuesProductVariant
		if err := rows.Scan(&i.ProductVariantID, &i.OptionValueID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOptions = `-- name: ListOptions :many
SELECT
  id, name, product_id, deleted_at
FROM
  options
WHERE
  CASE
    WHEN $1::uuid[] IS NULL THEN TRUE
    WHEN cardinality($1::uuid[]) = 0 THEN TRUE
    ELSE options.id = ANY ($1::uuid[])
  END
  AND CASE
    WHEN $2::uuid IS NULL THEN TRUE
    ELSE options.product_id = $2::uuid
  END
  AND CASE
    WHEN $3::text = 'exclude' THEN deleted_at IS NULL
    WHEN $3::text = 'only' THEN deleted_at IS NOT NULL
    WHEN $3::text = 'all' THEN TRUE
    ELSE deleted_at IS NULL
  END
ORDER BY
  options.id
`

type ListOptionsParams struct {
	IDs       []uuid.UUID
	ProductID pgtype.UUID
	Deleted   string
}

func (q *Queries) ListOptions(ctx context.Context, arg ListOptionsParams) ([]Option, error) {
	rows, err := q.db.Query(ctx, listOptions, arg.IDs, arg.ProductID, arg.Deleted)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Option
	for rows.Next() {
		var i Option
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ProductID,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const mergeOptionValuesFromTemp = `-- name: MergeOptionValuesFromTemp :exec
MERGE INTO option_values AS target
USING temp_option_values AS source
  ON target.id = source.id
WHEN MATCHED THEN
  UPDATE SET
    value = source.value,
    option_id = source.option_id,
    deleted_at = source.deleted_at
WHEN NOT MATCHED THEN
  INSERT (
    id,
    value,
    option_id,
    deleted_at
  )
  VALUES (
    source.id,
    source.value,
    source.option_id,
    source.deleted_at
  )
WHEN NOT MATCHED BY SOURCE AND target.option_id = sqlc.arg('option_id')::uuid THEN
  DELETE
`

func (q *Queries) MergeOptionValuesFromTemp(ctx context.Context) error {
	_, err := q.db.Exec(ctx, mergeOptionValuesFromTemp)
	return err
}

const mergeOptionValuesProductVariantsFromTemp = `-- name: MergeOptionValuesProductVariantsFromTemp :exec
MERGE INTO option_values_product_variants AS target
USING temp_option_values_product_variants AS source
  ON target.product_variant_id = source.product_variant_id AND target.option_value_id = source.option_value_id
WHEN NOT MATCHED THEN
  INSERT (
    product_variant_id,
    option_value_id
  )
  VALUES (
    source.product_variant_id,
    source.option_value_id
  )
WHEN NOT MATCHED BY SOURCE AND target.option_value_id IN (
  SELECT id FROM option_values WHERE option_id = sqlc.arg('option_id')::uuid
) THEN
  DELETE
`

func (q *Queries) MergeOptionValuesProductVariantsFromTemp(ctx context.Context) error {
	_, err := q.db.Exec(ctx, mergeOptionValuesProductVariantsFromTemp)
	return err
}

const upsertOption = `-- name: UpsertOption :exec
INSERT INTO options (
  id,
  name,
  product_id,
  deleted_at
)
VALUES (
  $1,
  $2,
  $3,
  $4
)
ON CONFLICT (id) DO UPDATE SET
  name = EXCLUDED.name,
  product_id = EXCLUDED.product_id,
  deleted_at = EXCLUDED.deleted_at
`

type UpsertOptionParams struct {
	ID        uuid.UUID
	Name      string
	ProductID uuid.UUID
	DeletedAt pgtype.Timestamp
}

func (q *Queries) UpsertOption(ctx context.Context, arg UpsertOptionParams) error {
	_, err := q.db.Exec(ctx, upsertOption,
		arg.ID,
		arg.Name,
		arg.ProductID,
		arg.DeletedAt,
	)
	return err
}
