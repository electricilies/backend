// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: product.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createProduct = `-- name: CreateProduct :one
INSERT INTO products (
  name,
  description
)
VALUES (
  $1,
  $2
)
RETURNING
  id, name, description, price, views_count, total_purchase, rating, trending_score, category_id, created_at, updated_at, deleted_at
`

type CreateProductParams struct {
	Name        string
	Description string
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, createProduct, arg.Name, arg.Description)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.ViewsCount,
		&i.TotalPurchase,
		&i.Rating,
		&i.TrendingScore,
		&i.CategoryID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createProductImages = `-- name: CreateProductImages :many
INSERT INTO product_images (
  url,
  "order",
  product_variant_id,
  product_id
)
SELECT
  UNNEST($1::text[]) AS url,
  UNNEST($2::integer[]) AS "order",
  UNNEST($3::integer[]) AS product_variant_id,
  $4
RETURNING
  id, url, created_at, "order", product_id, product_variant_id
`

type CreateProductImagesParams struct {
	URLs              []string
	Orders            []int32
	ProductVariantIDs []int32
	ProductID         pgtype.Int4
}

func (q *Queries) CreateProductImages(ctx context.Context, arg CreateProductImagesParams) ([]ProductImage, error) {
	rows, err := q.db.Query(ctx, createProductImages,
		arg.URLs,
		arg.Orders,
		arg.ProductVariantIDs,
		arg.ProductID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductImage
	for rows.Next() {
		var i ProductImage
		if err := rows.Scan(
			&i.ID,
			&i.URL,
			&i.CreatedAt,
			&i.Order,
			&i.ProductID,
			&i.ProductVariantID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createProductVariants = `-- name: CreateProductVariants :many
INSERT INTO product_variants (
  sku,
  price,
  quantity,
  product_id
)
SELECT
  UNNEST($1::text[]) AS sku,
  UNNEST($2::decimal[]) AS price,
  UNNEST($3::integer[]) AS quantity,
  $4
RETURNING
  id, sku, price, quantity, purchase_count, product_id, created_at, updated_at, deleted_at
`

type CreateProductVariantsParams struct {
	SKUs       []string
	Prices     []pgtype.Numeric
	Quantities []int32
	ProductID  int32
}

func (q *Queries) CreateProductVariants(ctx context.Context, arg CreateProductVariantsParams) ([]ProductVariant, error) {
	rows, err := q.db.Query(ctx, createProductVariants,
		arg.SKUs,
		arg.Prices,
		arg.Quantities,
		arg.ProductID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductVariant
	for rows.Next() {
		var i ProductVariant
		if err := rows.Scan(
			&i.ID,
			&i.SKU,
			&i.Price,
			&i.Quantity,
			&i.PurchaseCount,
			&i.ProductID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteProductImages = `-- name: DeleteProductImages :execrows
DELETE FROM
  product_images
WHERE
  id = ANY ($1::integer[])
`

type DeleteProductImagesParams struct {
	IDs []int32
}

func (q *Queries) DeleteProductImages(ctx context.Context, arg DeleteProductImagesParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteProductImages, arg.IDs)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteProductVariants = `-- name: DeleteProductVariants :execrows
UPDATE
  product_variants
SET
  deleted_at = NOW()
WHERE
  id = ANY ($1::integer[])
  AND deleted_at IS NULL
`

type DeleteProductVariantsParams struct {
	IDs []int32
}

func (q *Queries) DeleteProductVariants(ctx context.Context, arg DeleteProductVariantsParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteProductVariants, arg.IDs)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteProducts = `-- name: DeleteProducts :execrows
UPDATE
  products
SET
  deleted_at = NOW()
WHERE
  id = ANY ($1::integer[])
  AND deleted_at IS NULL
`

type DeleteProductsParams struct {
	IDs []int32
}

func (q *Queries) DeleteProducts(ctx context.Context, arg DeleteProductsParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteProducts, arg.IDs)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getProduct = `-- name: GetProduct :one
SELECT
  id, name, description, price, views_count, total_purchase, rating, trending_score, category_id, created_at, updated_at, deleted_at
FROM
  products
WHERE
  products.id = $1
  AND CASE
    WHEN $2::text = 'exclude' THEN deleted_at IS NOT NULL
    WHEN $2::text = 'only' THEN deleted_at IS NULL
    WHEN $2::text = 'all' THEN TRUE
    ELSE FALSE
  END
`

type GetProductParams struct {
	ID      int32
	Deleted string
}

func (q *Queries) GetProduct(ctx context.Context, arg GetProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, getProduct, arg.ID, arg.Deleted)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.ViewsCount,
		&i.TotalPurchase,
		&i.Rating,
		&i.TrendingScore,
		&i.CategoryID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getProductImage = `-- name: GetProductImage :one
SELECT
  id, url, created_at, "order", product_id, product_variant_id
FROM
  product_images
WHERE
  id = $1
`

type GetProductImageParams struct {
	ID int32
}

func (q *Queries) GetProductImage(ctx context.Context, arg GetProductImageParams) (ProductImage, error) {
	row := q.db.QueryRow(ctx, getProductImage, arg.ID)
	var i ProductImage
	err := row.Scan(
		&i.ID,
		&i.URL,
		&i.CreatedAt,
		&i.Order,
		&i.ProductID,
		&i.ProductVariantID,
	)
	return i, err
}

const linkProductAttributeValues = `-- name: LinkProductAttributeValues :execrows
INSERT INTO products_attribute_values (
  product_id,
  attribute_value_id
)
SELECT
  $1,
  UNNEST($2::integer[]) AS attribute_value_id
`

type LinkProductAttributeValuesParams struct {
	ProductID         int32
	AttributeValueIDs []int32
}

func (q *Queries) LinkProductAttributeValues(ctx context.Context, arg LinkProductAttributeValuesParams) (int64, error) {
	result, err := q.db.Exec(ctx, linkProductAttributeValues, arg.ProductID, arg.AttributeValueIDs)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const linkProductVariantsWithOptionValues = `-- name: LinkProductVariantsWithOptionValues :execrows
INSERT INTO option_values_product_variants (
  option_value_id,
  product_variant_id
)
SELECT
  UNNEST($1::integer[]) AS option_value_id,
  UNNEST($2::integer[]) AS product_variant_id
`

type LinkProductVariantsWithOptionValuesParams struct {
	OptionValueIDs    []int32
	ProductVariantIDs []int32
}

func (q *Queries) LinkProductVariantsWithOptionValues(ctx context.Context, arg LinkProductVariantsWithOptionValuesParams) (int64, error) {
	result, err := q.db.Exec(ctx, linkProductVariantsWithOptionValues, arg.OptionValueIDs, arg.ProductVariantIDs)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const listProductImages = `-- name: ListProductImages :many
SELECT
  id, url, created_at, "order", product_id, product_variant_id
FROM
  product_images
WHERE
  CASE
    WHEN $1::integer[] IS NULL THEN TRUE
    ELSE id = ANY ($1::integer[])
  END
  AND CASE
    WHEN $2::integer[] IS NULL THEN TRUE
    ELSE product_variant_id = ANY ($2)
  END
  AND CASE
    WHEN $3::integer[] IS NULL THEN TRUE
    ELSE product_id = ANY ($3::integer[])
  END
ORDER BY
  id ASC
`

type ListProductImagesParams struct {
	IDs               []int32
	ProductVariantIDs []int32
	ProductIDs        []int32
}

func (q *Queries) ListProductImages(ctx context.Context, arg ListProductImagesParams) ([]ProductImage, error) {
	rows, err := q.db.Query(ctx, listProductImages, arg.IDs, arg.ProductVariantIDs, arg.ProductIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductImage
	for rows.Next() {
		var i ProductImage
		if err := rows.Scan(
			&i.ID,
			&i.URL,
			&i.CreatedAt,
			&i.Order,
			&i.ProductID,
			&i.ProductVariantID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductVariants = `-- name: ListProductVariants :many
SELECT
  id, sku, price, quantity, purchase_count, product_id, created_at, updated_at, deleted_at
FROM
  product_variants
WHERE
  CASE
    WHEN $1::integer[] IS NULL THEN TRUE
    ELSE id = ANY ($1::integer[])
  END
  AND CASE
    WHEN $2::integer[] IS NULL THEN TRUE
    ELSE product_id = ANY ($2::integer[])
  END
  AND CASE
    WHEN $3::text = 'exclude' THEN deleted_at IS NOT NULL
    WHEN $3::text = 'only' THEN deleted_at IS NULL
    WHEN $3::text = 'all' THEN TRUE
    ELSE FALSE
  END
ORDER BY
  id
`

type ListProductVariantsParams struct {
	IDs        []int32
	ProductIDs []int32
	Deleted    string
}

func (q *Queries) ListProductVariants(ctx context.Context, arg ListProductVariantsParams) ([]ProductVariant, error) {
	rows, err := q.db.Query(ctx, listProductVariants, arg.IDs, arg.ProductIDs, arg.Deleted)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductVariant
	for rows.Next() {
		var i ProductVariant
		if err := rows.Scan(
			&i.ID,
			&i.SKU,
			&i.Price,
			&i.Quantity,
			&i.PurchaseCount,
			&i.ProductID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProducts = `-- name: ListProducts :many
SELECT
  products.id, products.name, products.description, products.price, products.views_count, products.total_purchase, products.rating, products.trending_score, products.category_id, products.created_at, products.updated_at, products.deleted_at,
  COUNT(*) OVER() AS current_count,
  COUNT(*) AS total_count
FROM
  products
LEFT JOIN (
  SELECT
    products.id,
    pdb.score(product.id) AS category_score
  FROM products
  INNER JOIN categories
    ON products.category_id = categories.id
  WHERE
    $1::text IS NULL
    OR (
      categories.name ||| ($1::text)::pdb.fuzzy(2)
      AND categories.deleted_at IS NULL
    )
) AS category_scores
  ON products.id = category_scores.id
WHERE
  CASE
    WHEN $2::integer[] IS NULL THEN TRUE
    ELSE products.id = ANY ($2::integer[])
  END
  AND CASE
    WHEN $1::text IS NULL THEN TRUE
    ELSE products.name ||| ($1::text)::pdb.fuzzy(products.trending_score)
  END
  AND CASE
    WHEN $3::decimal IS NULL THEN TRUE
    ELSE products.price >= $3::decimal
  END
  AND CASE
    WHEN $4::decimal IS NULL THEN TRUE
    ELSE products.price <= $4::decimal
  END
  AND CASE
    WHEN $5::real IS NULL THEN TRUE
    ELSE products.rating >= $5::real
  END
  AND CASE
    WHEN $6::integer[] IS NULL THEN TRUE
    ELSE products.category_id = ANY ($6::integer[])
  END
  AND CASE
    WHEN $7::text = 'exclude' THEN products.deleted_at IS NOT NULL
    WHEN $7::text = 'only' THEN products.deleted_at IS NULL
    WHEN $7::text = 'all' THEN TRUE
    ELSE FALSE
  END
ORDER BY
  CASE WHEN
    $1 IS NOT NULL THEN pdb.score(products.id) + category_scores
  END DESC,
  CASE WHEN
    $8::text = 'asc' THEN products.rating
  END ASC,
  CASE WHEN
    $8::text = 'desc' THEN products.rating
  END DESC,
  CASE WHEN
   $9::text = 'asc' THEN products.price
  END ASC,
  CASE WHEN
   $9::text = 'desc' THEN products.price
  END DESC
OFFSET COALESCE($10::integer, 0)
LIMIT COALESCE($11::integer, 20)
`

type ListProductsParams struct {
	Search      pgtype.Text
	IDs         []int32
	MinPrice    pgtype.Numeric
	MaxPrice    pgtype.Numeric
	Rating      pgtype.Float4
	CategoryIDs []int32
	Deleted     string
	SortRating  pgtype.Text
	SortPrice   pgtype.Text
	Offset      pgtype.Int4
	Limit       pgtype.Int4
}

type ListProductsRow struct {
	Product      Product
	CurrentCount int64
	TotalCount   int64
}

// This is used for list, search (with filter, order), suggest
func (q *Queries) ListProducts(ctx context.Context, arg ListProductsParams) ([]ListProductsRow, error) {
	rows, err := q.db.Query(ctx, listProducts,
		arg.Search,
		arg.IDs,
		arg.MinPrice,
		arg.MaxPrice,
		arg.Rating,
		arg.CategoryIDs,
		arg.Deleted,
		arg.SortRating,
		arg.SortPrice,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProductsRow
	for rows.Next() {
		var i ListProductsRow
		if err := rows.Scan(
			&i.Product.ID,
			&i.Product.Name,
			&i.Product.Description,
			&i.Product.Price,
			&i.Product.ViewsCount,
			&i.Product.TotalPurchase,
			&i.Product.Rating,
			&i.Product.TrendingScore,
			&i.Product.CategoryID,
			&i.Product.CreatedAt,
			&i.Product.UpdatedAt,
			&i.Product.DeletedAt,
			&i.CurrentCount,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProduct = `-- name: UpdateProduct :one
UPDATE
  products
SET
  name = COALESCE($1::text, name),
  description = COALESCE($2::text, description),
  views_count = COALESCE($3::integer, views_count),
  total_purchase = COALESCE($4::integer, purchase_count),
  trending_score = COALESCE($5::float, trending_score), -- TODO: Do we ever update this manually?
  category_id = COALESCE($6::integer, category_id),
  updated_at = COALESCE($7::timestamp, NOW())
WHERE
  id = $8
  AND deleted_at IS NULL
RETURNING
  id, name, description, price, views_count, total_purchase, rating, trending_score, category_id, created_at, updated_at, deleted_at
`

type UpdateProductParams struct {
	Name          pgtype.Text
	Description   pgtype.Text
	ViewsCount    pgtype.Int4
	TotalPurchase pgtype.Int4
	TrendingScore pgtype.Float8
	CategoryID    pgtype.Int4
	UpdatedAt     pgtype.Timestamp
	ID            int32
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, updateProduct,
		arg.Name,
		arg.Description,
		arg.ViewsCount,
		arg.TotalPurchase,
		arg.TrendingScore,
		arg.CategoryID,
		arg.UpdatedAt,
		arg.ID,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.ViewsCount,
		&i.TotalPurchase,
		&i.Rating,
		&i.TrendingScore,
		&i.CategoryID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateProductVariant = `-- name: UpdateProductVariant :one
UPDATE
  product_variants
SET
  sku = COALESCE($1::text, sku),
  price = COALESCE($2::decimal, price),
  quantity = COALESCE($3::integer, quantity),
  purchase_count = COALESCE($4::integer, purchase_count),
  updated_at = COALESCE($5::timestamp, NOW())
WHERE
  product_variants.id = $6
  AND product_variants.deleted_at IS NULL
RETURNING
  id, sku, price, quantity, purchase_count, product_id, created_at, updated_at, deleted_at
`

type UpdateProductVariantParams struct {
	SKU           pgtype.Text
	Price         pgtype.Numeric
	Quantity      pgtype.Int4
	PurchaseCount pgtype.Int4
	UpdatedAt     pgtype.Timestamp
	ID            int32
}

func (q *Queries) UpdateProductVariant(ctx context.Context, arg UpdateProductVariantParams) (ProductVariant, error) {
	row := q.db.QueryRow(ctx, updateProductVariant,
		arg.SKU,
		arg.Price,
		arg.Quantity,
		arg.PurchaseCount,
		arg.UpdatedAt,
		arg.ID,
	)
	var i ProductVariant
	err := row.Scan(
		&i.ID,
		&i.SKU,
		&i.Price,
		&i.Quantity,
		&i.PurchaseCount,
		&i.ProductID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
