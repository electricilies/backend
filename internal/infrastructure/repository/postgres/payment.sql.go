// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: payment.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPayment = `-- name: CreatePayment :one
WITH payments AS (
  INSERT INTO payments (
    amount,
    status_id,
    provider_id
  )
  VALUES (
    $1,
    $2,
    $3
  )
  RETURNING
    id, amount, updated_at, status_id, provider_id, order_id
)
SELECT
  payments.id, payments.amount, payments.updated_at, payments.status_id, payments.provider_id, payments.order_id,
  payment_statuses.id, payment_statuses.name,
  payment_providers.id, payment_providers.name
FROM payments
INNER JOIN payment_statuses
  ON payments.status_id = payment_statuses.id
INNER JOIN payment_providers
  ON payments.provider_id = payment_providers.id
`

type CreatePaymentParams struct {
	Amount     pgtype.Numeric
	StatusID   int32
	ProviderID int32
}

type CreatePaymentRow struct {
	Payment         Payment
	PaymentStatus   PaymentStatus
	PaymentProvider PaymentProvider
}

func (q *Queries) CreatePayment(ctx context.Context, arg CreatePaymentParams) (CreatePaymentRow, error) {
	row := q.db.QueryRow(ctx, createPayment, arg.Amount, arg.StatusID, arg.ProviderID)
	var i CreatePaymentRow
	err := row.Scan(
		&i.Payment.ID,
		&i.Payment.Amount,
		&i.Payment.UpdatedAt,
		&i.Payment.StatusID,
		&i.Payment.ProviderID,
		&i.Payment.OrderID,
		&i.PaymentStatus.ID,
		&i.PaymentStatus.Name,
		&i.PaymentProvider.ID,
		&i.PaymentProvider.Name,
	)
	return i, err
}

const getPayment = `-- name: GetPayment :one
SELECT
  payments.id, payments.amount, payments.updated_at, payments.status_id, payments.provider_id, payments.order_id
FROM
  payments
WHERE
  CASE
    WHEN $1::integer IS NULL THEN TRUE
    ELSE payments.id = $1::integer
  END
  AND CASE
    WHEN $2::integer IS NULL THEN TRUE
    ELSE payments.order_id = $2::integer
  END
`

type GetPaymentParams struct {
	ID      pgtype.Int4
	OrderID pgtype.Int4
}

type GetPaymentRow struct {
	Payment Payment
}

func (q *Queries) GetPayment(ctx context.Context, arg GetPaymentParams) (GetPaymentRow, error) {
	row := q.db.QueryRow(ctx, getPayment, arg.ID, arg.OrderID)
	var i GetPaymentRow
	err := row.Scan(
		&i.Payment.ID,
		&i.Payment.Amount,
		&i.Payment.UpdatedAt,
		&i.Payment.StatusID,
		&i.Payment.ProviderID,
		&i.Payment.OrderID,
	)
	return i, err
}

const getPaymentProvider = `-- name: GetPaymentProvider :one
SELECT
  id, name
FROM
  payment_providers
WHERE
  CASE
    WHEN $1::integer IS NULL THEN TRUE
    ELSE id = $1::integer
  END
  AND CASE
    WHEN $2::text IS NULL THEN TRUE
    ELSE name = $2::text
  END
`

type GetPaymentProviderParams struct {
	ID   pgtype.Int4
	Name pgtype.Text
}

func (q *Queries) GetPaymentProvider(ctx context.Context, arg GetPaymentProviderParams) (PaymentProvider, error) {
	row := q.db.QueryRow(ctx, getPaymentProvider, arg.ID, arg.Name)
	var i PaymentProvider
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const getPaymentStatus = `-- name: GetPaymentStatus :one
SELECT
  id, name
FROM
  payment_statuses
WHERE
  CASE
    WHEN $1::integer IS NULL THEN TRUE
    ELSE id = $1::integer
  END
  AND CASE
    WHEN $2::text IS NULL THEN TRUE
    ELSE name = $2::text
  END
`

type GetPaymentStatusParams struct {
	ID   pgtype.Int4
	Name pgtype.Text
}

func (q *Queries) GetPaymentStatus(ctx context.Context, arg GetPaymentStatusParams) (PaymentStatus, error) {
	row := q.db.QueryRow(ctx, getPaymentStatus, arg.ID, arg.Name)
	var i PaymentStatus
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const listPaymentProviders = `-- name: ListPaymentProviders :many
SELECT
  id, name
FROM
  payment_providers
WHERE
  CASE
    WHEN $1::integer[] IS NULL THEN TRUE
    ELSE id = ANY ($1::integer[])
  END
ORDER BY
  id
`

type ListPaymentProvidersParams struct {
	IDs []int32
}

func (q *Queries) ListPaymentProviders(ctx context.Context, arg ListPaymentProvidersParams) ([]PaymentProvider, error) {
	rows, err := q.db.Query(ctx, listPaymentProviders, arg.IDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PaymentProvider
	for rows.Next() {
		var i PaymentProvider
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPaymentStatuses = `-- name: ListPaymentStatuses :many
SELECT
  id, name
FROM
  payment_statuses
WHERE
  CASE
    WHEN $1::integer[] IS NULL THEN TRUE
    ELSE id = ANY ($1::integer[])
  END
ORDER BY
  id
`

type ListPaymentStatusesParams struct {
	IDs []int32
}

func (q *Queries) ListPaymentStatuses(ctx context.Context, arg ListPaymentStatusesParams) ([]PaymentStatus, error) {
	rows, err := q.db.Query(ctx, listPaymentStatuses, arg.IDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PaymentStatus
	for rows.Next() {
		var i PaymentStatus
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPayments = `-- name: ListPayments :many
SELECT
  payments.id, payments.amount, payments.updated_at, payments.status_id, payments.provider_id, payments.order_id,
  COUNT(*) OVER() AS current_count,
  COUNT(*) AS total_count
FROM
  payments
WHERE
  CASE
    WHEN $1::integer[] IS NULL THEN TRUE
    ELSE payments.id = ANY ($1::integer[])
  END
  AND CASE
    WHEN $2::integer[] IS NULL THEN TRUE
    ELSE payments.status_id = ANY ($2::integer[])
  END
  AND CASE
    WHEN $3::integer[] IS NULL THEN TRUE
    ELSE payments.provider_id = ANY ($3::integer[])
  END
  AND CASE
    WHEN $4::integer[] IS NULL THEN TRUE
    ELSE payments.order_id = ANY ($4::integer[])
  END
ORDER BY
  id DESC
OFFSET COALESCE($5::integer, 0)
LIMIT COALESCE($6::integer, 20)
`

type ListPaymentsParams struct {
	IDs         []int32
	StatusIds   []int32
	ProviderIds []int32
	OrderIds    []int32
	Offset      pgtype.Int4
	Limit       pgtype.Int4
}

type ListPaymentsRow struct {
	Payment      Payment
	CurrentCount int64
	TotalCount   int64
}

func (q *Queries) ListPayments(ctx context.Context, arg ListPaymentsParams) ([]ListPaymentsRow, error) {
	rows, err := q.db.Query(ctx, listPayments,
		arg.IDs,
		arg.StatusIds,
		arg.ProviderIds,
		arg.OrderIds,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPaymentsRow
	for rows.Next() {
		var i ListPaymentsRow
		if err := rows.Scan(
			&i.Payment.ID,
			&i.Payment.Amount,
			&i.Payment.UpdatedAt,
			&i.Payment.StatusID,
			&i.Payment.ProviderID,
			&i.Payment.OrderID,
			&i.CurrentCount,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePayment = `-- name: UpdatePayment :one
UPDATE payments
SET
  amount = COALESCE($1::decimal(12, 0), amount),
  provider_id = COALESCE($2::integer, provider_id),
  status_id = COALESCE($3::integer, status_id),
  updated_at = COALESCE($4::timestamp, NOW())
WHERE
  id = $5::integer
RETURNING
  id, amount, updated_at, status_id, provider_id, order_id
`

type UpdatePaymentParams struct {
	Amount     pgtype.Numeric
	ProviderID pgtype.Int4
	StatusID   pgtype.Int4
	UpdatedAt  pgtype.Timestamp
	ID         int32
}

func (q *Queries) UpdatePayment(ctx context.Context, arg UpdatePaymentParams) (Payment, error) {
	row := q.db.QueryRow(ctx, updatePayment,
		arg.Amount,
		arg.ProviderID,
		arg.StatusID,
		arg.UpdatedAt,
		arg.ID,
	)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.Amount,
		&i.UpdatedAt,
		&i.StatusID,
		&i.ProviderID,
		&i.OrderID,
	)
	return i, err
}
