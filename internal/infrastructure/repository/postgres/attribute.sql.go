// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: attribute.sql

package postgres

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countAttributeValues = `-- name: CountAttributeValues :one
SELECT
  COUNT(*) AS count
FROM
  attribute_values
WHERE
  CASE
    WHEN $1::uuid[] IS NULL THEN TRUE
    WHEN cardinality($1::uuid[]) = 0 THEN TRUE
    ELSE id = ANY ($1::uuid[])
  END
  AND CASE
    WHEN $2::uuid IS NULL THEN TRUE
    ELSE attribute_id = $2::uuid
  END
  AND CASE
    WHEN $3::uuid[] IS NULL THEN TRUE
    WHEN cardinality($3::uuid[]) = 0 THEN TRUE
     ELSE attribute_id = ANY ($3::uuid[])
  END
  AND CASE
    WHEN $4::text = 'exclude' THEN deleted_at IS NULL
    WHEN $4::text = 'only' THEN deleted_at IS NOT NULL
    WHEN $4::text = 'all' THEN TRUE
    ELSE deleted_at IS NULL
  END
`

type CountAttributeValuesParams struct {
	IDs          []uuid.UUID
	AttributeID  pgtype.UUID
	AttributeIDs []uuid.UUID
	Deleted      string
}

func (q *Queries) CountAttributeValues(ctx context.Context, arg CountAttributeValuesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAttributeValues,
		arg.IDs,
		arg.AttributeID,
		arg.AttributeIDs,
		arg.Deleted,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAttributes = `-- name: CountAttributes :one
SELECT
  COUNT(*) AS count
FROM
  attributes
WHERE
  CASE
    WHEN $1::uuid[] IS NULL THEN TRUE
    WHEN cardinality($1::uuid[]) = 0 THEN TRUE
    ELSE id = ANY ($1::uuid[])
  END
  AND CASE
    WHEN $2::text = 'exclude' THEN deleted_at IS NULL
    WHEN $2::text = 'only' THEN deleted_at IS NOT NULL
    WHEN $2::text = 'all' THEN TRUE
    ELSE deleted_at IS NULL
  END
`

type CountAttributesParams struct {
	IDs     []uuid.UUID
	Deleted string
}

func (q *Queries) CountAttributes(ctx context.Context, arg CountAttributesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAttributes, arg.IDs, arg.Deleted)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createTempTableAttributeValues = `-- name: CreateTempTableAttributeValues :exec
CREATE TEMPORARY TABLE temp_attribute_values (
  id UUID PRIMARY KEY,
  attribute_id UUID NOT NULL,
  value TEXT NOT NULL,
  deleted_at TIMESTAMP
) ON COMMIT DROP
`

func (q *Queries) CreateTempTableAttributeValues(ctx context.Context) error {
	_, err := q.db.Exec(ctx, createTempTableAttributeValues)
	return err
}

const getAttribute = `-- name: GetAttribute :one
SELECT
  id, code, name, deleted_at
FROM
  attributes
WHERE
  id = $1::uuid
  AND CASE
    WHEN $2::text = 'exclude' THEN deleted_at IS NULL
    WHEN $2::text = 'only' THEN deleted_at IS NOT NULL
    WHEN $2::text = 'all' THEN TRUE
    ELSE deleted_at IS NULL
  END
`

type GetAttributeParams struct {
	ID      uuid.UUID
	Deleted string
}

func (q *Queries) GetAttribute(ctx context.Context, arg GetAttributeParams) (Attribute, error) {
	row := q.db.QueryRow(ctx, getAttribute, arg.ID, arg.Deleted)
	var i Attribute
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.DeletedAt,
	)
	return i, err
}

type InsertTempTableAttributeValuesParams struct {
	ID          uuid.UUID
	AttributeID uuid.UUID
	Value       string
	DeletedAt   pgtype.Timestamp
}

const listAttributeValues = `-- name: ListAttributeValues :many
SELECT
  id, attribute_id, value, deleted_at
FROM
  attribute_values
WHERE
  CASE
    WHEN $1::uuid[] IS NULL THEN TRUE
    WHEN cardinality($1::uuid[]) = 0 THEN TRUE
    ELSE id = ANY ($1::uuid[])
  END
  AND CASE
    WHEN $2::uuid IS NULL THEN TRUE
    ELSE attribute_id = $2::uuid
  END
  AND CASE
    WHEN $3::uuid[] IS NULL THEN TRUE
    WHEN cardinality($3::uuid[]) = 0 THEN TRUE
     ELSE attribute_id = ANY ($3::uuid[])
  END
  AND CASE
    WHEN $4::text IS NULL THEN TRUE
    ELSE value ||| ($4::text)::pdb.fuzzy(2)
  END
  AND CASE
    WHEN $5::text = 'exclude' THEN deleted_at IS NULL
    WHEN $5::text = 'only' THEN deleted_at IS NOT NULL
    WHEN $5::text = 'all' THEN TRUE
    ELSE deleted_at IS NULL
  END
ORDER BY
  CASE WHEN $4::text IS NOT NULL THEN pdb.score(id) END DESC,
  id ASC
OFFSET $6::integer
LIMIT NULLIF($7::integer, 0)
`

type ListAttributeValuesParams struct {
	IDs          []uuid.UUID
	AttributeID  pgtype.UUID
	AttributeIDs []uuid.UUID
	Search       *string
	Deleted      string
	Offset       int32
	Limit        int32
}

func (q *Queries) ListAttributeValues(ctx context.Context, arg ListAttributeValuesParams) ([]AttributeValue, error) {
	rows, err := q.db.Query(ctx, listAttributeValues,
		arg.IDs,
		arg.AttributeID,
		arg.AttributeIDs,
		arg.Search,
		arg.Deleted,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AttributeValue
	for rows.Next() {
		var i AttributeValue
		if err := rows.Scan(
			&i.ID,
			&i.AttributeID,
			&i.Value,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAttributes = `-- name: ListAttributes :many
SELECT
  id, code, name, deleted_at
FROM
  attributes
WHERE
  CASE
    WHEN $1::uuid[] IS NULL THEN TRUE
    WHEN cardinality($1::uuid[]) = 0 THEN TRUE
    ELSE id = ANY ($1::uuid[])
  END
  AND CASE
    WHEN $2::text IS NULL THEN TRUE
    ELSE
      code ||| ($2::text)::pdb.fuzzy(2)
      OR name ||| ($2::text)::pdb.fuzzy(2)
  END
  AND CASE
    WHEN $3::text = 'exclude' THEN deleted_at IS NULL
    WHEN $3::text = 'only' THEN deleted_at IS NOT NULL
    WHEN $3::text = 'all' THEN TRUE
    ELSE deleted_at IS NULL
  END
ORDER BY
  CASE WHEN $2::text IS NOT NULL THEN pdb.score(id) END DESC,
  id ASC
OFFSET $4::integer
LIMIT NULLIF($5::integer, 0)
`

type ListAttributesParams struct {
	IDs     []uuid.UUID
	Search  *string
	Deleted string
	Offset  int32
	Limit   int32
}

func (q *Queries) ListAttributes(ctx context.Context, arg ListAttributesParams) ([]Attribute, error) {
	rows, err := q.db.Query(ctx, listAttributes,
		arg.IDs,
		arg.Search,
		arg.Deleted,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Attribute
	for rows.Next() {
		var i Attribute
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductsAttributeValues = `-- name: ListProductsAttributeValues :many
SELECT
  product_id, attribute_value_id
FROM
  products_attribute_values
WHERE
  CASE
    WHEN $1::uuid[] IS NULL THEN TRUE
    WHEN cardinality($1::uuid[]) = 0 THEN TRUE
    ELSE product_id = ANY ($1::uuid[])
  END
  AND CASE
    WHEN $2::uuid[] IS NULL THEN TRUE
    WHEN cardinality($2::uuid[]) = 0 THEN TRUE
    ELSE attribute_value_id = ANY ($2::uuid[])
  END
ORDER BY
  product_id ASC,
  attribute_value_id ASC
OFFSET $3::integer
LIMIT NULLIF($4::integer, 0)
`

type ListProductsAttributeValuesParams struct {
	ProductIDs        []uuid.UUID
	AttributeValueIDs []uuid.UUID
	Offset            int32
	Limit             int32
}

func (q *Queries) ListProductsAttributeValues(ctx context.Context, arg ListProductsAttributeValuesParams) ([]ProductsAttributeValue, error) {
	rows, err := q.db.Query(ctx, listProductsAttributeValues,
		arg.ProductIDs,
		arg.AttributeValueIDs,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductsAttributeValue
	for rows.Next() {
		var i ProductsAttributeValue
		if err := rows.Scan(&i.ProductID, &i.AttributeValueID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const mergeAttributeValuesFromTemp = `-- name: MergeAttributeValuesFromTemp :exec
MERGE INTO attribute_values AS target
USING temp_attribute_values AS source
ON target.id = source.id
   OR (
        target.attribute_id = source.attribute_id
        AND source.id IS NULL
      )
WHEN MATCHED AND source.id IS NOT NULL THEN
  UPDATE SET
    attribute_id = source.attribute_id,
    value = source.value,
    deleted_at = source.deleted_at
WHEN NOT MATCHED THEN
  INSERT (
    id,
    attribute_id,
    value,
    deleted_at
  )
  VALUES (
    source.id,
    source.attribute_id,
    source.value,
    source.deleted_at
  )
WHEN MATCHED AND source.id IS NULL THEN
  DELETE
`

func (q *Queries) MergeAttributeValuesFromTemp(ctx context.Context) error {
	_, err := q.db.Exec(ctx, mergeAttributeValuesFromTemp)
	return err
}

const upsertAttribute = `-- name: UpsertAttribute :exec
INSERT INTO attributes (
  id,
  code,
  name,
  deleted_at
)
VALUES (
  $1,
  $2,
  $3,
  $4
)
ON CONFLICT (id) DO UPDATE SET
  code = EXCLUDED.code,
  name = EXCLUDED.name,
  deleted_at = EXCLUDED.deleted_at
`

type UpsertAttributeParams struct {
	ID        uuid.UUID
	Code      string
	Name      string
	DeletedAt pgtype.Timestamp
}

func (q *Queries) UpsertAttribute(ctx context.Context, arg UpsertAttributeParams) error {
	_, err := q.db.Exec(ctx, upsertAttribute,
		arg.ID,
		arg.Code,
		arg.Name,
		arg.DeletedAt,
	)
	return err
}
