// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: product.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createProduct = `-- name: CreateProduct :one
INSERT INTO products (
  name,
  description
)
VALUES (
  $1,
  $2
)
RETURNING
  id, name, description, price, views_count, total_purchase, rating, trending_score, category_id, created_at, updated_at, deleted_at
`

type CreateProductParams struct {
	Name        string
	Description string
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, createProduct, arg.Name, arg.Description)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.ViewsCount,
		&i.TotalPurchase,
		&i.Rating,
		&i.TrendingScore,
		&i.CategoryID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createProductImages = `-- name: CreateProductImages :many
INSERT INTO product_images (
  url,
  "order",
  product_variant_id,
  product_id
)
SELECT
  UNNEST($1::text[]) AS url,
  UNNEST($2::integer[]) AS "order",
  UNNEST($3::integer[]) AS product_variant_id,
  $4
RETURNING
  id, url, created_at, "order", product_id, product_variant_id
`

type CreateProductImagesParams struct {
	Urls              []string
	Orders            []int32
	ProductVariantIDs []int32
	ProductID         pgtype.Int4
}

func (q *Queries) CreateProductImages(ctx context.Context, arg CreateProductImagesParams) ([]ProductImage, error) {
	rows, err := q.db.Query(ctx, createProductImages,
		arg.Urls,
		arg.Orders,
		arg.ProductVariantIDs,
		arg.ProductID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductImage
	for rows.Next() {
		var i ProductImage
		if err := rows.Scan(
			&i.ID,
			&i.URL,
			&i.CreatedAt,
			&i.Order,
			&i.ProductID,
			&i.ProductVariantID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createProductVariants = `-- name: CreateProductVariants :many
INSERT INTO product_variants (
  sku,
  price,
  quantity,
  product_id
)
SELECT
  UNNEST($1::text[]) AS sku,
  UNNEST($2::decimal[]) AS price,
  UNNEST($3::integer[]) AS quantity,
  $4
RETURNING
  id, sku, price, quantity, purchase_count, product_id, created_at, updated_at, deleted_at
`

type CreateProductVariantsParams struct {
	Skus       []string
	Prices     []pgtype.Numeric
	Quantities []int32
	ProductID  int32
}

func (q *Queries) CreateProductVariants(ctx context.Context, arg CreateProductVariantsParams) ([]ProductVariant, error) {
	rows, err := q.db.Query(ctx, createProductVariants,
		arg.Skus,
		arg.Prices,
		arg.Quantities,
		arg.ProductID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductVariant
	for rows.Next() {
		var i ProductVariant
		if err := rows.Scan(
			&i.ID,
			&i.SKU,
			&i.Price,
			&i.Quantity,
			&i.PurchaseCount,
			&i.ProductID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteLinkedProductAttributeValues = `-- name: DeleteLinkedProductAttributeValues :execrows
WITH deleted_links AS (
  SELECT
    UNNEST($1::integer[]) AS product_id,
    UNNEST($2::integer[]) AS attribute_value_id
)
DELETE FROM
  products_attribute_values
USING
  deleted_links
WHERE
  products_attribute_values.product_id = deleted_links.product_id
  AND products_attribute_values.attribute_value_id = deleted_links.attribute_value_id
`

type DeleteLinkedProductAttributeValuesParams struct {
	ProductID         []int32
	AttributeValueIDs []int32
}

func (q *Queries) DeleteLinkedProductAttributeValues(ctx context.Context, arg DeleteLinkedProductAttributeValuesParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteLinkedProductAttributeValues, arg.ProductID, arg.AttributeValueIDs)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteLinkedProductVariantsOptionValues = `-- name: DeleteLinkedProductVariantsOptionValues :execrows
WITH deleted_links AS (
  SELECT
    UNNEST($1::integer[]) AS product_variant_id,
    UNNEST($2::integer[]) AS option_value_id
)
DELETE FROM
  option_values_product_variants
USING
  deleted_links
WHERE
  option_values_product_variants.product_variant_id = deleted_links.product_variant_id
  AND option_values_product_variants.option_value_id = deleted_links.option_value_id
`

type DeleteLinkedProductVariantsOptionValuesParams struct {
	ProductVariantIDs []int32
	OptionValueIDs    []int32
}

func (q *Queries) DeleteLinkedProductVariantsOptionValues(ctx context.Context, arg DeleteLinkedProductVariantsOptionValuesParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteLinkedProductVariantsOptionValues, arg.ProductVariantIDs, arg.OptionValueIDs)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteProductImages = `-- name: DeleteProductImages :execrows
DELETE FROM
  product_images
WHERE
  id = ANY ($1::integer[])
`

type DeleteProductImagesParams struct {
	Ids []int32
}

func (q *Queries) DeleteProductImages(ctx context.Context, arg DeleteProductImagesParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteProductImages, arg.Ids)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteProductVariants = `-- name: DeleteProductVariants :execrows
UPDATE
  product_variants
SET
  deleted_at = NOW()
WHERE
  id = ANY ($1::integer[])
  AND deleted_at IS NULL
`

type DeleteProductVariantsParams struct {
	Ids []int32
}

func (q *Queries) DeleteProductVariants(ctx context.Context, arg DeleteProductVariantsParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteProductVariants, arg.Ids)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteProducts = `-- name: DeleteProducts :execrows
UPDATE
  products
SET
  deleted_at = NOW()
WHERE
  id = ANY ($1::integer[])
  AND deleted_at IS NULL
`

type DeleteProductsParams struct {
	Ids []int32
}

func (q *Queries) DeleteProducts(ctx context.Context, arg DeleteProductsParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteProducts, arg.Ids)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getProductByID = `-- name: GetProductByID :one
SELECT
  id, name, description, price, views_count, total_purchase, rating, trending_score, category_id, created_at, updated_at, deleted_at
FROM
  products
WHERE
  products.id = $1
  AND CASE
    WHEN $2::bool THEN deleted_at IS NOT NULL
    WHEN $2::bool = FALSE THEN deleted_at IS NULL
    ELSE TRUE
  END
`

type GetProductByIDParams struct {
	ID                 int32
	IncludeDeletedOnly pgtype.Bool
}

func (q *Queries) GetProductByID(ctx context.Context, arg GetProductByIDParams) (Product, error) {
	row := q.db.QueryRow(ctx, getProductByID, arg.ID, arg.IncludeDeletedOnly)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.ViewsCount,
		&i.TotalPurchase,
		&i.Rating,
		&i.TrendingScore,
		&i.CategoryID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const linkProductAttributeValues = `-- name: LinkProductAttributeValues :execrows
INSERT INTO products_attribute_values (
  product_id,
  attribute_value_id
)
SELECT
  $1,
  UNNEST($2::integer[]) AS attribute_value_id
`

type LinkProductAttributeValuesParams struct {
	ProductID         int32
	AttributeValueIDs []int32
}

func (q *Queries) LinkProductAttributeValues(ctx context.Context, arg LinkProductAttributeValuesParams) (int64, error) {
	result, err := q.db.Exec(ctx, linkProductAttributeValues, arg.ProductID, arg.AttributeValueIDs)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const linkProductVariantsWithOptionValues = `-- name: LinkProductVariantsWithOptionValues :execrows
INSERT INTO option_values_product_variants (
  option_value_id,
  product_variant_id
)
SELECT
  UNNEST($1::integer[]) AS option_value_id,
  UNNEST($2::integer[]) AS product_variant_id
`

type LinkProductVariantsWithOptionValuesParams struct {
	OptionValueIDs    []int32
	ProductVariantIDs []int32
}

func (q *Queries) LinkProductVariantsWithOptionValues(ctx context.Context, arg LinkProductVariantsWithOptionValuesParams) (int64, error) {
	result, err := q.db.Exec(ctx, linkProductVariantsWithOptionValues, arg.OptionValueIDs, arg.ProductVariantIDs)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const listProductImages = `-- name: ListProductImages :many
SELECT
  id, url, created_at, "order", product_id, product_variant_id
FROM
  product_images
WHERE
  CASE
    WHEN $1::integer[] IS NULL THEN TRUE
    ELSE id = ANY ($1::integer[])
  END
  AND CASE
    WHEN $2::integer[] IS NULL THEN TRUE
    ELSE product_variant_id = ANY ($2)
  END
  AND CASE
    WHEN $3::integer[] IS NULL THEN TRUE
    ELSE product_id = ANY ($3::integer[])
  END
ORDER BY
  id ASC
`

type ListProductImagesParams struct {
	Ids               []int32
	ProductVariantIDs []int32
	ProductIDs        []int32
}

func (q *Queries) ListProductImages(ctx context.Context, arg ListProductImagesParams) ([]ProductImage, error) {
	rows, err := q.db.Query(ctx, listProductImages, arg.Ids, arg.ProductVariantIDs, arg.ProductIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductImage
	for rows.Next() {
		var i ProductImage
		if err := rows.Scan(
			&i.ID,
			&i.URL,
			&i.CreatedAt,
			&i.Order,
			&i.ProductID,
			&i.ProductVariantID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductVariants = `-- name: ListProductVariants :one
SELECT
  id, sku, price, quantity, purchase_count, product_id, created_at, updated_at, deleted_at
FROM
  product_variants
WHERE
  CASE
    WHEN $1::integer[] IS NULL THEN TRUE
    ELSE id = ANY ($1::integer[])
  END
  AND CASE
    WHEN $2::integer[] IS NULL THEN TRUE
    ELSE product_id = ANY ($2::integer[])
  END
  AND CASE
    WHEN $3::bool THEN deleted_at IS NOT NULL
    WHEN $3::bool = FALSE THEN deleted_at IS NULL
    ELSE TRUE
  END
ORDER BY
  id
`

type ListProductVariantsParams struct {
	Ids                []int32
	ProductIDs         []int32
	IncludeDeletedOnly pgtype.Bool
}

func (q *Queries) ListProductVariants(ctx context.Context, arg ListProductVariantsParams) (ProductVariant, error) {
	row := q.db.QueryRow(ctx, listProductVariants, arg.Ids, arg.ProductIDs, arg.IncludeDeletedOnly)
	var i ProductVariant
	err := row.Scan(
		&i.ID,
		&i.SKU,
		&i.Price,
		&i.Quantity,
		&i.PurchaseCount,
		&i.ProductID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const listProducts = `-- name: ListProducts :many
SELECT
  products.id, products.name, products.description, products.price, products.views_count, products.total_purchase, products.rating, products.trending_score, products.category_id, products.created_at, products.updated_at, products.deleted_at,
  COUNT(*) OVER() AS current_count,
  COUNT(*) AS total_count
FROM
  products
LEFT JOIN (
  SELECT
    products.id,
    pdb.score(product.id) AS category_score
  FROM products
  INNER JOIN categories
    ON products.category_id = categories.id
  WHERE
    $1::text IS NULL
    OR (
      categories.name ||| ($1::text)::pdb.fuzzy(2)
      AND categories.deleted_at IS NULL
    )
) AS category_scores
  ON products.id = category_scores.id
WHERE
  CASE
    WHEN $2::integer[] IS NULL THEN TRUE
    ELSE products.id = ANY ($2::integer[])
  END
  AND CASE
    WHEN $1::text IS NULL THEN TRUE
    ELSE products.name ||| ($1::text)::pdb.fuzzy(products.trending_score)
  END
  AND CASE
    WHEN $3::decimal IS NULL THEN TRUE
    ELSE products.price >= $3::decimal
  END
  AND CASE
    WHEN $4::decimal IS NULL THEN TRUE
    ELSE products.price <= $4::decimal
  END
  AND CASE
    WHEN $5::real IS NULL THEN TRUE
    ELSE products.rating >= $5::real
  END
  AND CASE
    WHEN $6::integer[] IS NULL THEN TRUE
    ELSE products.category_id = ANY ($6::integer[])
  END
  AND CASE
    WHEN $7::bool THEN products.deleted_at IS NOT NULL
    WHEN $7::bool = FALSE THEN products.deleted_at IS NULL
    ELSE TRUE
  END
ORDER BY
  CASE WHEN
    $1 IS NOT NULL THEN pdb.score(products.id) + category_scores
  END DESC,
  CASE WHEN
    $8::bool = TRUE THEN products.rating
  END ASC,
  CASE WHEN
    $8::bool = FALSE THEN products.rating
  END DESC,
  CASE WHEN
   $9::bool = TRUE THEN products.price
  END ASC,
  CASE WHEN
   $9::bool = FALSE THEN products.price
  END DESC
OFFSET COALESCE($10::integer, 0)
LIMIT COALESCE($11::integer, 20)
`

type ListProductsParams struct {
	Search             pgtype.Text
	Ids                []int32
	MinPrice           pgtype.Numeric
	MaxPrice           pgtype.Numeric
	Rating             pgtype.Float4
	CategoryIDs        []int32
	IncludeDeletedOnly pgtype.Bool
	SortRatingAsc      pgtype.Bool
	SortPriceAsc       pgtype.Bool
	Offset             pgtype.Int4
	Limit              pgtype.Int4
}

type ListProductsRow struct {
	Product      Product
	CurrentCount int64
	TotalCount   int64
}

// This is used for list, search (with filter, order), suggest
func (q *Queries) ListProducts(ctx context.Context, arg ListProductsParams) ([]ListProductsRow, error) {
	rows, err := q.db.Query(ctx, listProducts,
		arg.Search,
		arg.Ids,
		arg.MinPrice,
		arg.MaxPrice,
		arg.Rating,
		arg.CategoryIDs,
		arg.IncludeDeletedOnly,
		arg.SortRatingAsc,
		arg.SortPriceAsc,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProductsRow
	for rows.Next() {
		var i ListProductsRow
		if err := rows.Scan(
			&i.Product.ID,
			&i.Product.Name,
			&i.Product.Description,
			&i.Product.Price,
			&i.Product.ViewsCount,
			&i.Product.TotalPurchase,
			&i.Product.Rating,
			&i.Product.TrendingScore,
			&i.Product.CategoryID,
			&i.Product.CreatedAt,
			&i.Product.UpdatedAt,
			&i.Product.DeletedAt,
			&i.CurrentCount,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProductByID = `-- name: UpdateProductByID :execrows
UPDATE
  products
SET
  name = COALESCE($1::text, name),
  description = COALESCE($2::text, description),
  views_count = COALESCE($3::integer, views_count),
  total_purchase = COALESCE($4::integer, purchase_count),
  trending_score = COALESCE($5::float, trending_score), -- TODO: Do we ever update this manually?
  updated_at = NOW()
WHERE
  id = $6
  AND deleted_at IS NULL
`

type UpdateProductByIDParams struct {
	Name          pgtype.Text
	Description   pgtype.Text
	ViewsCount    pgtype.Int4
	TotalPurchase pgtype.Int4
	TrendingScore pgtype.Float8
	ID            int32
}

func (q *Queries) UpdateProductByID(ctx context.Context, arg UpdateProductByIDParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateProductByID,
		arg.Name,
		arg.Description,
		arg.ViewsCount,
		arg.TotalPurchase,
		arg.TrendingScore,
		arg.ID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateProductVariantsByIDs = `-- name: UpdateProductVariantsByIDs :execrows
WITH updated_variants AS (
  SELECT
    UNNEST($1::integer[]) AS id,
    UNNEST($2::text[]) AS sku,
    UNNEST($3::decimal[]) AS price,
    UNNEST($4::integer[]) AS quantity,
    UNNEST($5::integer[]) AS purchase_count
)
UPDATE
  product_variants
SET
  sku = COALESCE(updated_variants.sku, product_variants.sku),
  price = COALESCE(updated_variants.price, product_variants.price),
  quantity = COALESCE(updated_variants.quantity, product_variants.quantity),
  purchase_count = COALESCE(updated_variants.purchase_count, product_variants.purchase_count),
  updated_at = NOW()
FROM
  updated_variants
WHERE
  product_variants.id = updated_variants.id
  AND product_variants.deleted_at IS NULL
`

type UpdateProductVariantsByIDsParams struct {
	Ids            []int32
	Skus           []string
	Prices         []pgtype.Numeric
	Quantities     []int32
	PurchaseCounts []int32
}

func (q *Queries) UpdateProductVariantsByIDs(ctx context.Context, arg UpdateProductVariantsByIDsParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateProductVariantsByIDs,
		arg.Ids,
		arg.Skus,
		arg.Prices,
		arg.Quantities,
		arg.PurchaseCounts,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
