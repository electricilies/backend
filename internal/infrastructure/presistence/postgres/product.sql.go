// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: product.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

const createProduct = `-- name: CreateProduct :exec
INSERT INTO products (
  name,
  description
)
VALUES (
  $1,
  $2
)
`

type CreateProductParams struct {
	Name        string
	Description string
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) error {
	_, err := q.db.Exec(ctx, createProduct, arg.Name, arg.Description)
	return err
}

const createProductImages = `-- name: CreateProductImages :execresult
INSERT INTO product_images (
  url,
  "order",
  product_id,
  product_variant_id
)
SELECT
  UNNEST($1::text[]) AS url,
  UNNEST($2::integer[]) AS "order",
  $3,
  UNNEST($4::integer[]) AS product_variant_id
RETURNING
  id, url, created_at, "order", product_id, product_variant_id
`

type CreateProductImagesParams struct {
	Urls              []string
	Orders            []int32
	ProductID         int32
	ProductVariantIds []int32
}

func (q *Queries) CreateProductImages(ctx context.Context, arg CreateProductImagesParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, createProductImages,
		arg.Urls,
		arg.Orders,
		arg.ProductID,
		arg.ProductVariantIds,
	)
}

const createProductVariants = `-- name: CreateProductVariants :execresult
INSERT INTO product_variants (
  sku,
  price,
  quantity,
  product_id
)
SELECT
  UNNEST($1::text[]) AS sku,
  UNNEST($2::decimal[]) AS price,
  UNNEST($3::integer[]) AS quantity,
  $4
`

type CreateProductVariantsParams struct {
	Skus       []string
	Prices     []pgtype.Numeric
	Quantities []int32
	ProductID  int32
}

func (q *Queries) CreateProductVariants(ctx context.Context, arg CreateProductVariantsParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, createProductVariants,
		arg.Skus,
		arg.Prices,
		arg.Quantities,
		arg.ProductID,
	)
}

const getAllProducts = `-- name: GetAllProducts :many
SELECT
  product_variants.id, sku, price, quantity, purchase_count, product_variants.product_id, product_variants.created_at, product_variants.deleted_at, product_images.id, url, product_images.created_at, "order", product_images.product_id, product_images.product_variant_id, products_attribute_values.product_id, attribute_value_id, attribute_values.id, attribute_id, attribute_values.value, attributes.id, code, attributes.name, option_values_product_variants.product_variant_id, option_value_id, option_values.id, option_values.value, option_id, options.id, options.name, options.product_id, products_categories.product_id, category_id, categories.id, categories.name, categories.created_at, categories.deleted_at
FROM
  sqlc.embed(products),
  sqlc.embed(product_variants),
  sqlc.embed(product_images),
  sqlc.embed(products_attribute_values),
  sqlc.embed(attribute_values),
  sqlc.embed(attributes),
  sqlc.embed(option_values_product_variants),
  sqlc.embed(option_values),
  sqlc.embed(options),
  sqlc.embed(categories),
  sqlc.embed(products_categories)
INNER JOIN product_variants
  ON products.id = product_variants.product_id
INNER JOIN product_images
  ON product_variants.id = product_images.product_variant_id
INNER JOIN products_attribute_values
  ON products.id = products_attribute_values.product_id
INNER JOIN attribute_values
  ON products_attribute_values.attribute_value_id = attribute_values.id
INNER JOIN attributes
  ON attribute_values.attribute_id = attributes.id
INNER JOIN option_values_product_variants
  ON product_variants.id = option_values_product_variants.product_variant_id
INNER JOIN option_values
  ON option_values_product_variants.option_value_id = option_values.id
INNER JOIN options
  ON option_values.option_id = options.id
INNER JOIN products_categories
  ON products.id = products_categories.product_id
INNER JOIN categories
  ON products_categories.category_id = categories.id
WHERE
  products.deleted_at IS NULL
OFFSET COALESCE($1::integer, 0)
LIMIT COALESCE($2::integer, 20)
`

type GetAllProductsParams struct {
	Offset pgtype.Int4
	Limit  pgtype.Int4
}

type GetAllProductsRow struct {
	ID                 int32
	SKU                string
	Price              pgtype.Numeric
	Quantity           int32
	PurchaseCount      int32
	ProductID          int32
	CreatedAt          pgtype.Timestamp
	DeletedAt          pgtype.Timestamp
	ID_2               int32
	URL                string
	CreatedAt_2        pgtype.Timestamp
	Order              int32
	ProductID_2        int32
	ProductVariantID   pgtype.Int4
	ProductID_3        int32
	AttributeValueID   int32
	ID_3               int32
	AttributeID        int32
	Value              string
	ID_4               int32
	Code               string
	Name               string
	ProductVariantID_2 int32
	OptionValueID      int32
	ID_5               int32
	Value_2            string
	OptionID           int32
	ID_6               int32
	Name_2             string
	ProductID_4        int32
	ProductID_5        int32
	CategoryID         int32
	ID_7               int32
	Name_3             string
	CreatedAt_3        pgtype.Timestamp
	DeletedAt_2        pgtype.Timestamp
}

func (q *Queries) GetAllProducts(ctx context.Context, arg GetAllProductsParams) ([]GetAllProductsRow, error) {
	rows, err := q.db.Query(ctx, getAllProducts, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllProductsRow
	for rows.Next() {
		var i GetAllProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.SKU,
			&i.Price,
			&i.Quantity,
			&i.PurchaseCount,
			&i.ProductID,
			&i.CreatedAt,
			&i.DeletedAt,
			&i.ID_2,
			&i.URL,
			&i.CreatedAt_2,
			&i.Order,
			&i.ProductID_2,
			&i.ProductVariantID,
			&i.ProductID_3,
			&i.AttributeValueID,
			&i.ID_3,
			&i.AttributeID,
			&i.Value,
			&i.ID_4,
			&i.Code,
			&i.Name,
			&i.ProductVariantID_2,
			&i.OptionValueID,
			&i.ID_5,
			&i.Value_2,
			&i.OptionID,
			&i.ID_6,
			&i.Name_2,
			&i.ProductID_4,
			&i.ProductID_5,
			&i.CategoryID,
			&i.ID_7,
			&i.Name_3,
			&i.CreatedAt_3,
			&i.DeletedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductByID = `-- name: GetProductByID :one
SELECT
  product_variants.id, sku, price, quantity, purchase_count, product_variants.product_id, product_variants.created_at, product_variants.deleted_at, product_images.id, url, product_images.created_at, "order", product_images.product_id, product_images.product_variant_id, products_attribute_values.product_id, attribute_value_id, attribute_values.id, attribute_id, attribute_values.value, attributes.id, code, attributes.name, option_values_product_variants.product_variant_id, option_value_id, option_values.id, option_values.value, option_id, options.id, options.name, options.product_id, products_categories.product_id, category_id, categories.id, categories.name, categories.created_at, categories.deleted_at
FROM
  sqlc.embed(products),
  sqlc.embed(product_variants),
  sqlc.embed(product_images),
  sqlc.embed(products_attribute_values),
  sqlc.embed(attribute_values),
  sqlc.embed(attributes),
  sqlc.embed(option_values_product_variants),
  sqlc.embed(option_values),
  sqlc.embed(options),
  sqlc.embed(categories),
  sqlc.embed(products_categories)
INNER JOIN product_variants
  ON products.id = product_variants.product_id
INNER JOIN product_images
  ON product_variants.id = product_images.product_variant_id
INNER JOIN products_attribute_values
  ON products.id = products_attribute_values.product_id
INNER JOIN attribute_values
  ON products_attribute_values.attribute_value_id = attribute_values.id
INNER JOIN attributes
  ON attribute_values.attribute_id = attributes.id
INNER JOIN option_values_product_variants
  ON product_variants.id = option_values_product_variants.product_variant_id
INNER JOIN option_values
  ON option_values_product_variants.option_value_id = option_values.id
INNER JOIN options
  ON option_values.option_id = options.id
INNER JOIN products_categories
  ON products.id = products_categories.product_id
INNER JOIN categories
  ON products_categories.category_id = categories.id
WHERE
  products.id = $1::integer -- sqlc requires this
  AND products.deleted_at IS NULL
`

type GetProductByIDParams struct {
	ID int32
}

type GetProductByIDRow struct {
	ID                 int32
	SKU                string
	Price              pgtype.Numeric
	Quantity           int32
	PurchaseCount      int32
	ProductID          int32
	CreatedAt          pgtype.Timestamp
	DeletedAt          pgtype.Timestamp
	ID_2               int32
	URL                string
	CreatedAt_2        pgtype.Timestamp
	Order              int32
	ProductID_2        int32
	ProductVariantID   pgtype.Int4
	ProductID_3        int32
	AttributeValueID   int32
	ID_3               int32
	AttributeID        int32
	Value              string
	ID_4               int32
	Code               string
	Name               string
	ProductVariantID_2 int32
	OptionValueID      int32
	ID_5               int32
	Value_2            string
	OptionID           int32
	ID_6               int32
	Name_2             string
	ProductID_4        int32
	ProductID_5        int32
	CategoryID         int32
	ID_7               int32
	Name_3             string
	CreatedAt_3        pgtype.Timestamp
	DeletedAt_2        pgtype.Timestamp
}

func (q *Queries) GetProductByID(ctx context.Context, arg GetProductByIDParams) (GetProductByIDRow, error) {
	row := q.db.QueryRow(ctx, getProductByID, arg.ID)
	var i GetProductByIDRow
	err := row.Scan(
		&i.ID,
		&i.SKU,
		&i.Price,
		&i.Quantity,
		&i.PurchaseCount,
		&i.ProductID,
		&i.CreatedAt,
		&i.DeletedAt,
		&i.ID_2,
		&i.URL,
		&i.CreatedAt_2,
		&i.Order,
		&i.ProductID_2,
		&i.ProductVariantID,
		&i.ProductID_3,
		&i.AttributeValueID,
		&i.ID_3,
		&i.AttributeID,
		&i.Value,
		&i.ID_4,
		&i.Code,
		&i.Name,
		&i.ProductVariantID_2,
		&i.OptionValueID,
		&i.ID_5,
		&i.Value_2,
		&i.OptionID,
		&i.ID_6,
		&i.Name_2,
		&i.ProductID_4,
		&i.ProductID_5,
		&i.CategoryID,
		&i.ID_7,
		&i.Name_3,
		&i.CreatedAt_3,
		&i.DeletedAt_2,
	)
	return i, err
}

const linkProductAttributeValues = `-- name: LinkProductAttributeValues :execrows
INSERT INTO products_attribute_values (
  product_id,
  attribute_value_id
)
SELECT
  $1,
  UNNEST($2::integer[]) AS attribute_value_id
`

type LinkProductAttributeValuesParams struct {
	ProductID         int32
	AttributeValueIds []int32
}

func (q *Queries) LinkProductAttributeValues(ctx context.Context, arg LinkProductAttributeValuesParams) (int64, error) {
	result, err := q.db.Exec(ctx, linkProductAttributeValues, arg.ProductID, arg.AttributeValueIds)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const linkProductCategories = `-- name: LinkProductCategories :execrows
INSERT INTO products_categories (
  product_id,
  category_id
)
SELECT
  $1,
  UNNEST($2::integer[]) AS category_id
`

type LinkProductCategoriesParams struct {
	ProductID   int32
	CategoryIds []int32
}

func (q *Queries) LinkProductCategories(ctx context.Context, arg LinkProductCategoriesParams) (int64, error) {
	result, err := q.db.Exec(ctx, linkProductCategories, arg.ProductID, arg.CategoryIds)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const linkProductOptions = `-- name: LinkProductOptions :execrows
INSERT INTO option_values_product_variants (
  option_value_id,
  product_variant_id
)
SELECT
  UNNEST($1::integer[]) AS option_value_id,
  UNNEST($2::integer[]) AS product_variant_id
`

type LinkProductOptionsParams struct {
	OptionValueIds    []int32
	ProductVariantIds []int32
}

func (q *Queries) LinkProductOptions(ctx context.Context, arg LinkProductOptionsParams) (int64, error) {
	result, err := q.db.Exec(ctx, linkProductOptions, arg.OptionValueIds, arg.ProductVariantIds)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
