// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: product.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

const createProduct = `-- name: CreateProduct :one
INSERT INTO products (
  name,
  description
)
VALUES (
  $1,
  $2
)
RETURNING
  id, name, description, price, views_count, total_purchase, rating, trending_score, category_id, created_at, updated_at, deleted_at
`

type CreateProductParams struct {
	Name        string
	Description string
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, createProduct, arg.Name, arg.Description)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.ViewsCount,
		&i.TotalPurchase,
		&i.Rating,
		&i.TrendingScore,
		&i.CategoryID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createProductImages = `-- name: CreateProductImages :execresult
INSERT INTO product_images (
  url,
  "order",
  product_variant_id
)
SELECT
  UNNEST($1::text[]) AS url,
  UNNEST($2::integer[]) AS "order",
  UNNEST($3::integer[]) AS product_variant_id
`

type CreateProductImagesParams struct {
	Urls              []string
	Orders            []int32
	ProductVariantIds []int32
}

func (q *Queries) CreateProductImages(ctx context.Context, arg CreateProductImagesParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, createProductImages, arg.Urls, arg.Orders, arg.ProductVariantIds)
}

const createProductVariants = `-- name: CreateProductVariants :execresult
INSERT INTO product_variants (
  sku,
  price,
  quantity,
  product_id
)
SELECT
  UNNEST($1::text[]) AS sku,
  UNNEST($2::decimal[]) AS price,
  UNNEST($3::integer[]) AS quantity,
  $4
`

type CreateProductVariantsParams struct {
	Skus       []string
	Prices     []pgtype.Numeric
	Quantities []int32
	ProductID  int32
}

func (q *Queries) CreateProductVariants(ctx context.Context, arg CreateProductVariantsParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, createProductVariants,
		arg.Skus,
		arg.Prices,
		arg.Quantities,
		arg.ProductID,
	)
}

const deleteProducts = `-- name: DeleteProducts :execrows

UPDATE
  products
SET
  deleted_at = NOW()
WHERE
  deleted_at IS NULL
  AND id = ANY($1::integer[])
`

type DeleteProductsParams struct {
	Ids []int32
}

// naee: UpdateProductImages :execrows
// TODO: Will we implement this?
func (q *Queries) DeleteProducts(ctx context.Context, arg DeleteProductsParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteProducts, arg.Ids)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getProductByID = `-- name: GetProductByID :one
SELECT
  products.id, products.name, products.description, products.price, products.views_count, products.total_purchase, products.rating, products.trending_score, products.category_id, products.created_at, products.updated_at, products.deleted_at,
  product_variants.id, product_variants.sku, product_variants.price, product_variants.quantity, product_variants.purchase_count, product_variants.product_id, product_variants.created_at, product_variants.updated_at, product_variants.deleted_at, product_variants.id, product_variants.sku, product_variants.price, product_variants.quantity, product_variants.purchase_count, product_variants.product_id, product_variants.created_at, product_variants.updated_at, product_variants.deleted_at,
  product_images.id, product_images.url, product_images.created_at, product_images."order", product_images.product_variant_id, product_images.id, product_images.url, product_images.created_at, product_images."order", product_images.product_variant_id,
  products_attribute_values.product_id, products_attribute_values.attribute_value_id, products_attribute_values.product_id, products_attribute_values.attribute_value_id,
  attribute_values.id, attribute_values.attribute_id, attribute_values.value, attribute_values.id, attribute_values.attribute_id, attribute_values.value,
  attributes.id, attributes.code, attributes.name, attributes.deleted_at, attributes.id, attributes.code, attributes.name, attributes.deleted_at,
  option_values_product_variants.product_variant_id, option_values_product_variants.option_value_id, option_values_product_variants.product_variant_id, option_values_product_variants.option_value_id,
  option_values.id, option_values.value, option_values.option_id, option_values.id, option_values.value, option_values.option_id,
  options.id, options.name, options.product_id, options.deleted_at, options.id, options.name, options.product_id, options.deleted_at,
  categories.id, categories.name, categories.created_at, categories.updated_at, categories.deleted_at, categories.id, categories.name, categories.created_at, categories.updated_at, categories.deleted_at
FROM
  products,
  product_variants,
  product_images,
  products_attribute_values,
  attribute_values,
  attributes,
  option_values_product_variants,
  option_values,
  options,
  categories
INNER JOIN product_variants
  ON products.id = product_variants.product_id
INNER JOIN product_images
  ON product_variants.id = product_images.product_variant_id
INNER JOIN products_attribute_values
  ON products.id = products_attribute_values.product_id
INNER JOIN attribute_values
  ON products_attribute_values.attribute_value_id = attribute_values.id
INNER JOIN attributes
  ON attribute_values.attribute_id = attributes.id
INNER JOIN option_values_product_variants
  ON product_variants.id = option_values_product_variants.product_variant_id
INNER JOIN option_values
  ON option_values_product_variants.option_value_id = option_values.id
INNER JOIN options
  ON option_values.option_id = options.id
INNER JOIN categories
  ON products.category_id = categories.id
WHERE
  products.id = $1::integer -- sqlc requires this
  AND products.deleted_at IS NULL
  AND categories.deleted_at IS NULL
  AND attributes.deleted_at IS NULL
  AND options.deleted_at IS NULL
`

type GetProductByIDParams struct {
	ID int32
}

type GetProductByIDRow struct {
	Product                    Product
	ProductVariant             ProductVariant
	ProductImage               ProductImage
	ProductsAttributeValue     ProductsAttributeValue
	AttributeValue             AttributeValue
	Attribute                  Attribute
	OptionValuesProductVariant OptionValuesProductVariant
	OptionValue                OptionValue
	Option                     Option
	Category                   Category
}

func (q *Queries) GetProductByID(ctx context.Context, arg GetProductByIDParams) (GetProductByIDRow, error) {
	row := q.db.QueryRow(ctx, getProductByID, arg.ID)
	var i GetProductByIDRow
	err := row.Scan(
		&i.Product.ID,
		&i.Product.Name,
		&i.Product.Description,
		&i.Product.Price,
		&i.Product.ViewsCount,
		&i.Product.TotalPurchase,
		&i.Product.Rating,
		&i.Product.TrendingScore,
		&i.Product.CategoryID,
		&i.Product.CreatedAt,
		&i.Product.UpdatedAt,
		&i.Product.DeletedAt,
		&i.ProductVariant.ID,
		&i.ProductVariant.SKU,
		&i.ProductVariant.Price,
		&i.ProductVariant.Quantity,
		&i.ProductVariant.PurchaseCount,
		&i.ProductVariant.ProductID,
		&i.ProductVariant.CreatedAt,
		&i.ProductVariant.UpdatedAt,
		&i.ProductVariant.DeletedAt,
		&i.ProductImage.ID,
		&i.ProductImage.URL,
		&i.ProductImage.CreatedAt,
		&i.ProductImage.Order,
		&i.ProductImage.ProductVariantID,
		&i.ProductsAttributeValue.ProductID,
		&i.ProductsAttributeValue.AttributeValueID,
		&i.AttributeValue.ID,
		&i.AttributeValue.AttributeID,
		&i.AttributeValue.Value,
		&i.Attribute.ID,
		&i.Attribute.Code,
		&i.Attribute.Name,
		&i.Attribute.DeletedAt,
		&i.OptionValuesProductVariant.ProductVariantID,
		&i.OptionValuesProductVariant.OptionValueID,
		&i.OptionValue.ID,
		&i.OptionValue.Value,
		&i.OptionValue.OptionID,
		&i.Option.ID,
		&i.Option.Name,
		&i.Option.ProductID,
		&i.Option.DeletedAt,
		&i.Category.ID,
		&i.Category.Name,
		&i.Category.CreatedAt,
		&i.Category.UpdatedAt,
		&i.Category.DeletedAt,
	)
	return i, err
}

const getProducts = `-- name: GetProducts :many
SELECT
  products.id, products.name, products.description, products.price, products.views_count, products.total_purchase, products.rating, products.trending_score, products.category_id, products.created_at, products.updated_at, products.deleted_at,
  product_variants.id, product_variants.sku, product_variants.price, product_variants.quantity, product_variants.purchase_count, product_variants.product_id, product_variants.created_at, product_variants.updated_at, product_variants.deleted_at, product_variants.id, product_variants.sku, product_variants.price, product_variants.quantity, product_variants.purchase_count, product_variants.product_id, product_variants.created_at, product_variants.updated_at, product_variants.deleted_at,
  product_images.id, product_images.url, product_images.created_at, product_images."order", product_images.product_variant_id, product_images.id, product_images.url, product_images.created_at, product_images."order", product_images.product_variant_id,
  products_attribute_values.product_id, products_attribute_values.attribute_value_id, products_attribute_values.product_id, products_attribute_values.attribute_value_id,
  attribute_values.id, attribute_values.attribute_id, attribute_values.value, attribute_values.id, attribute_values.attribute_id, attribute_values.value,
  attributes.id, attributes.code, attributes.name, attributes.deleted_at, attributes.id, attributes.code, attributes.name, attributes.deleted_at,
  option_values_product_variants.product_variant_id, option_values_product_variants.option_value_id, option_values_product_variants.product_variant_id, option_values_product_variants.option_value_id,
  option_values.id, option_values.value, option_values.option_id, option_values.id, option_values.value, option_values.option_id,
  options.id, options.name, options.product_id, options.deleted_at, options.id, options.name, options.product_id, options.deleted_at,
  categories.id, categories.name, categories.created_at, categories.updated_at, categories.deleted_at, categories.id, categories.name, categories.created_at, categories.updated_at, categories.deleted_at,
  COUNT(*) OVER() AS current_count,
  COUNT(*) AS total_count
FROM
  products,
  product_variants,
  product_images,
  products_attribute_values,
  attribute_values,
  attributes,
  option_values_product_variants,
  option_values,
  options,
  categories
INNER JOIN product_variants
  ON products.id = product_variants.product_id
INNER JOIN product_images
  ON product_variants.id = product_images.product_variant_id
INNER JOIN products_attribute_values
  ON products.id = products_attribute_values.product_id
INNER JOIN attribute_values
  ON products_attribute_values.attribute_value_id = attribute_values.id
INNER JOIN attributes
  ON attribute_values.attribute_id = attributes.id
INNER JOIN option_values_product_variants
  ON product_variants.id = option_values_product_variants.product_variant_id
INNER JOIN option_values
  ON option_values_product_variants.option_value_id = option_values.id
INNER JOIN options
  ON option_values.option_id = options.id
INNER JOIN categories
  ON products.category_id = categories.id
WHERE
  products.deleted_at IS NULL
  AND categories.deleted_at IS NULL
  AND attributes.deleted_at IS NULL
  AND options.deleted_at IS NULL
  AND (
    $1::integer IS NULL
    OR categories.id = $1::integer
  )
  AND (
    $2::text IS NULL
    OR products.name ||| $2::pdb.fuzzy(products.trending_score) -- TODO: Have to check does paradedb support this
    OR categories.name ||| $2::pdb.fuzzy(2)
  )
  -- TODO: Do we support rating?
OFFSET COALESCE($3::integer, 0)
LIMIT COALESCE($4::integer, 20)
`

type GetProductsParams struct {
	CategoryID pgtype.Int4
	Search     pgtype.Text
	Offset     pgtype.Int4
	Limit      pgtype.Int4
}

type GetProductsRow struct {
	Product                    Product
	ProductVariant             ProductVariant
	ProductImage               ProductImage
	ProductsAttributeValue     ProductsAttributeValue
	AttributeValue             AttributeValue
	Attribute                  Attribute
	OptionValuesProductVariant OptionValuesProductVariant
	OptionValue                OptionValue
	Option                     Option
	Category                   Category
	CurrentCount               int64
	TotalCount                 int64
}

func (q *Queries) GetProducts(ctx context.Context, arg GetProductsParams) ([]GetProductsRow, error) {
	rows, err := q.db.Query(ctx, getProducts,
		arg.CategoryID,
		arg.Search,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsRow
	for rows.Next() {
		var i GetProductsRow
		if err := rows.Scan(
			&i.Product.ID,
			&i.Product.Name,
			&i.Product.Description,
			&i.Product.Price,
			&i.Product.ViewsCount,
			&i.Product.TotalPurchase,
			&i.Product.Rating,
			&i.Product.TrendingScore,
			&i.Product.CategoryID,
			&i.Product.CreatedAt,
			&i.Product.UpdatedAt,
			&i.Product.DeletedAt,
			&i.ProductVariant.ID,
			&i.ProductVariant.SKU,
			&i.ProductVariant.Price,
			&i.ProductVariant.Quantity,
			&i.ProductVariant.PurchaseCount,
			&i.ProductVariant.ProductID,
			&i.ProductVariant.CreatedAt,
			&i.ProductVariant.UpdatedAt,
			&i.ProductVariant.DeletedAt,
			&i.ProductImage.ID,
			&i.ProductImage.URL,
			&i.ProductImage.CreatedAt,
			&i.ProductImage.Order,
			&i.ProductImage.ProductVariantID,
			&i.ProductsAttributeValue.ProductID,
			&i.ProductsAttributeValue.AttributeValueID,
			&i.AttributeValue.ID,
			&i.AttributeValue.AttributeID,
			&i.AttributeValue.Value,
			&i.Attribute.ID,
			&i.Attribute.Code,
			&i.Attribute.Name,
			&i.Attribute.DeletedAt,
			&i.OptionValuesProductVariant.ProductVariantID,
			&i.OptionValuesProductVariant.OptionValueID,
			&i.OptionValue.ID,
			&i.OptionValue.Value,
			&i.OptionValue.OptionID,
			&i.Option.ID,
			&i.Option.Name,
			&i.Option.ProductID,
			&i.Option.DeletedAt,
			&i.Category.ID,
			&i.Category.Name,
			&i.Category.CreatedAt,
			&i.Category.UpdatedAt,
			&i.Category.DeletedAt,
			&i.CurrentCount,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSuggestedProducts = `-- name: GetSuggestedProducts :many

UPDATE
  products
SET
  name = COALESCE(sql.narg('name')::text, name),
  description = COALESCE(sql.narg('description')::text, description),
  views_count = COALESCE(sql.narg('views_count')::integer, views_count),
  total_purchase = COALESCE(sql.narg('total_purchase')::integer, purchase_count),
  trending_score = COALESCE(sql.narg('trending_score')::float, trending_score) -- TODO: Do we ever update this manually?
WHERE
  deleted_at IS NULL
  AND id = $1
RETURNING
  id, name, description, price, views_count, total_purchase, rating, trending_score, category_id, created_at, updated_at, deleted_at
`

type GetSuggestedProductsParams struct {
	ID int32
}

// TODO: Will we implement this?
func (q *Queries) GetSuggestedProducts(ctx context.Context, arg GetSuggestedProductsParams) ([]Product, error) {
	rows, err := q.db.Query(ctx, getSuggestedProducts, arg.ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.ViewsCount,
			&i.TotalPurchase,
			&i.Rating,
			&i.TrendingScore,
			&i.CategoryID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const linkProductAttributeValues = `-- name: LinkProductAttributeValues :execrows
INSERT INTO products_attribute_values (
  product_id,
  attribute_value_id
)
SELECT
  $1,
  UNNEST($2::integer[]) AS attribute_value_id
`

type LinkProductAttributeValuesParams struct {
	ProductID         int32
	AttributeValueIds []int32
}

func (q *Queries) LinkProductAttributeValues(ctx context.Context, arg LinkProductAttributeValuesParams) (int64, error) {
	result, err := q.db.Exec(ctx, linkProductAttributeValues, arg.ProductID, arg.AttributeValueIds)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const linkProductOptionValues = `-- name: LinkProductOptionValues :execrows
INSERT INTO option_values_product_variants (
  option_value_id,
  product_variant_id
)
SELECT
  UNNEST($1::integer[]) AS option_value_id,
  UNNEST($2::integer[]) AS product_variant_id
`

type LinkProductOptionValuesParams struct {
	OptionValueIds    []int32
	ProductVariantIds []int32
}

func (q *Queries) LinkProductOptionValues(ctx context.Context, arg LinkProductOptionValuesParams) (int64, error) {
	result, err := q.db.Exec(ctx, linkProductOptionValues, arg.OptionValueIds, arg.ProductVariantIds)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateProductVariants = `-- name: UpdateProductVariants :execrows
WITH updated_variants AS (
  SELECT
    UNNEST($1::integer[]) AS id,
    UNNEST($2::text[]) AS sku,
    UNNEST($3::decimal[]) AS price,
    UNNEST($4::integer[]) AS quantity,
    UNNEST($5::integer[]) AS purchase_count,
    $6::timestamp AS updated_at
)
UPDATE
  product_variants
SET
  sku = updated_variants.sku,
  price = updated_variants.price,
  quantity = updated_variants.quantity,
  purchase_count = updated_variants.purchase_count
  -- FIXME: Maybe missing updated_at field?
FROM
  updated_variants
WHERE
  product_variants.id = updated_variants.id
  AND product_variants.deleted_at IS NULL
`

type UpdateProductVariantsParams struct {
	Ids            []int32
	Skus           []string
	Prices         []pgtype.Numeric
	Quantities     []int32
	PurchaseCounts []int32
	UpdatedAt      pgtype.Timestamp
}

func (q *Queries) UpdateProductVariants(ctx context.Context, arg UpdateProductVariantsParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateProductVariants,
		arg.Ids,
		arg.Skus,
		arg.Prices,
		arg.Quantities,
		arg.PurchaseCounts,
		arg.UpdatedAt,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
