// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: payment.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPayment = `-- name: CreatePayment :one
WITH payments AS (
  INSERT INTO payments (
    amount,
    payment_method_id,
    payment_status_id,
    payment_provider_id
  )
  VALUES (
    $1,
    $2,
    $3,
    $4
  )
  RETURNING
    id, amount, updated_at, payment_method_id, payment_status_id, payment_provider_id
)
SELECT
  payments.id, payments.amount, payments.updated_at, payments.payment_method_id, payments.payment_status_id, payments.payment_provider_id,
  payment_statuses.id, payment_statuses.name,
  payment_methods.id, payment_methods.name,
  payment_providers.id, payment_providers.name
FROM payments
INNER JOIN payment_statuses
  ON payments.payment_status_id = payment_statuses.id
INNER JOIN payment_methods
  ON payments.payment_method_id = payment_methods.id
INNER JOIN payment_providers
  ON payments.payment_provider_id = payment_providers.id
`

type CreatePaymentParams struct {
	Amount            pgtype.Numeric
	PaymentMethodID   int32
	PaymentStatusID   int32
	PaymentProviderID int32
}

type CreatePaymentRow struct {
	Payment         Payment
	PaymentStatus   PaymentStatus
	PaymentMethod   PaymentMethod
	PaymentProvider PaymentProvider
}

func (q *Queries) CreatePayment(ctx context.Context, arg CreatePaymentParams) (CreatePaymentRow, error) {
	row := q.db.QueryRow(ctx, createPayment,
		arg.Amount,
		arg.PaymentMethodID,
		arg.PaymentStatusID,
		arg.PaymentProviderID,
	)
	var i CreatePaymentRow
	err := row.Scan(
		&i.Payment.ID,
		&i.Payment.Amount,
		&i.Payment.UpdatedAt,
		&i.Payment.PaymentMethodID,
		&i.Payment.PaymentStatusID,
		&i.Payment.PaymentProviderID,
		&i.PaymentStatus.ID,
		&i.PaymentStatus.Name,
		&i.PaymentMethod.ID,
		&i.PaymentMethod.Name,
		&i.PaymentProvider.ID,
		&i.PaymentProvider.Name,
	)
	return i, err
}

const getPaymentByOrderID = `-- name: GetPaymentByOrderID :one
SELECT
  payments.id, payments.amount, payments.updated_at, payments.payment_method_id, payments.payment_status_id, payments.payment_provider_id,
  payment_statuses.id, payment_statuses.name,
  payment_methods.id, payment_methods.name,
  payment_providers.id, payment_providers.name
FROM
  payments
INNER JOIN orders
  ON payments.id = orders.payment_id
INNER JOIN payment_statuses
  ON payments.payment_status_id = payment_statuses.id
INNER JOIN payment_methods
  ON payments.payment_method_id = payment_methods.id
INNER JOIN payment_providers
  ON payments.payment_provider_id = payment_providers.id
WHERE
  orders.id = $1
`

type GetPaymentByOrderIDParams struct {
	OrderID int32
}

type GetPaymentByOrderIDRow struct {
	Payment         Payment
	PaymentStatus   PaymentStatus
	PaymentMethod   PaymentMethod
	PaymentProvider PaymentProvider
}

func (q *Queries) GetPaymentByOrderID(ctx context.Context, arg GetPaymentByOrderIDParams) (GetPaymentByOrderIDRow, error) {
	row := q.db.QueryRow(ctx, getPaymentByOrderID, arg.OrderID)
	var i GetPaymentByOrderIDRow
	err := row.Scan(
		&i.Payment.ID,
		&i.Payment.Amount,
		&i.Payment.UpdatedAt,
		&i.Payment.PaymentMethodID,
		&i.Payment.PaymentStatusID,
		&i.Payment.PaymentProviderID,
		&i.PaymentStatus.ID,
		&i.PaymentStatus.Name,
		&i.PaymentMethod.ID,
		&i.PaymentMethod.Name,
		&i.PaymentProvider.ID,
		&i.PaymentProvider.Name,
	)
	return i, err
}

const getPayments = `-- name: GetPayments :many
SELECT
  payments.id, payments.amount, payments.updated_at, payments.payment_method_id, payments.payment_status_id, payments.payment_provider_id,
  payment_statuses.id, payment_statuses.name,
  payment_methods.id, payment_methods.name,
  payment_providers.id, payment_providers.name,
  COUNT(*) OVER() AS current_count,
  COUNT(*) AS total_count
FROM
  payments
INNER JOIN payment_statuses
  ON payments.payment_status_id = payment_statuses.id
INNER JOIN payment_methods
  ON payments.payment_method_id = payment_methods.id
INNER JOIN payment_providers
  ON payments.payment_provider_id = payment_providers.id
ORDER BY
  payments.id DESC -- FIXME: Or?? Updated at?
OFFSET COALESCE($1::integer, 0)
LIMIT COALESCE($2::integer, 20)
`

type GetPaymentsParams struct {
	Offset pgtype.Int4
	Limit  pgtype.Int4
}

type GetPaymentsRow struct {
	Payment         Payment
	PaymentStatus   PaymentStatus
	PaymentMethod   PaymentMethod
	PaymentProvider PaymentProvider
	CurrentCount    int64
	TotalCount      int64
}

func (q *Queries) GetPayments(ctx context.Context, arg GetPaymentsParams) ([]GetPaymentsRow, error) {
	rows, err := q.db.Query(ctx, getPayments, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPaymentsRow
	for rows.Next() {
		var i GetPaymentsRow
		if err := rows.Scan(
			&i.Payment.ID,
			&i.Payment.Amount,
			&i.Payment.UpdatedAt,
			&i.Payment.PaymentMethodID,
			&i.Payment.PaymentStatusID,
			&i.Payment.PaymentProviderID,
			&i.PaymentStatus.ID,
			&i.PaymentStatus.Name,
			&i.PaymentMethod.ID,
			&i.PaymentMethod.Name,
			&i.PaymentProvider.ID,
			&i.PaymentProvider.Name,
			&i.CurrentCount,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePaymentStatus = `-- name: UpdatePaymentStatus :one
WITH payments AS (
  UPDATE payments
  SET
    payment_status_id = $1,
    updated_at = NOW()
  WHERE
    payments.id = $2 -- # HACK: Wtf sqlc?
  RETURNING
    id, amount, updated_at, payment_method_id, payment_status_id, payment_provider_id
)
SELECT
  payments.id, payments.amount, payments.updated_at, payments.payment_method_id, payments.payment_status_id, payments.payment_provider_id,
  payment_statuses.id, payment_statuses.name,
  payment_methods.id, payment_methods.name,
  payment_providers.id, payment_providers.name
FROM payments
INNER JOIN payment_statuses
  ON payments.payment_status_id = payment_statuses.id
INNER JOIN payment_methods
  ON payments.payment_method_id = payment_methods.id
INNER JOIN payment_providers
  ON payments.payment_provider_id = payment_providers.id
`

type UpdatePaymentStatusParams struct {
	PaymentStatusID int32
	ID              int32
}

type UpdatePaymentStatusRow struct {
	Payment         Payment
	PaymentStatus   PaymentStatus
	PaymentMethod   PaymentMethod
	PaymentProvider PaymentProvider
}

func (q *Queries) UpdatePaymentStatus(ctx context.Context, arg UpdatePaymentStatusParams) (UpdatePaymentStatusRow, error) {
	row := q.db.QueryRow(ctx, updatePaymentStatus, arg.PaymentStatusID, arg.ID)
	var i UpdatePaymentStatusRow
	err := row.Scan(
		&i.Payment.ID,
		&i.Payment.Amount,
		&i.Payment.UpdatedAt,
		&i.Payment.PaymentMethodID,
		&i.Payment.PaymentStatusID,
		&i.Payment.PaymentProviderID,
		&i.PaymentStatus.ID,
		&i.PaymentStatus.Name,
		&i.PaymentMethod.ID,
		&i.PaymentMethod.Name,
		&i.PaymentProvider.ID,
		&i.PaymentProvider.Name,
	)
	return i, err
}
