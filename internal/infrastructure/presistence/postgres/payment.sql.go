// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: payment.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPayment = `-- name: CreatePayment :one
WITH payments AS (
  INSERT INTO payments (
    amount,
    status_id,
    provider_id
  )
  VALUES (
    $1,
    $2,
    $3
  )
  RETURNING
    id, amount, updated_at, status_id, provider_id, order_id
)
SELECT
  payments.id, payments.amount, payments.updated_at, payments.status_id, payments.provider_id, payments.order_id,
  payment_statuses.id, payment_statuses.name,
  payment_providers.id, payment_providers.name
FROM payments
INNER JOIN payment_statuses
  ON payments.status_id = payment_statuses.id
INNER JOIN payment_providers
  ON payments.provider_id = payment_providers.id
`

type CreatePaymentParams struct {
	Amount     pgtype.Numeric
	StatusID   int32
	ProviderID int32
}

type CreatePaymentRow struct {
	Payment         Payment
	PaymentStatus   PaymentStatus
	PaymentProvider PaymentProvider
}

func (q *Queries) CreatePayment(ctx context.Context, arg CreatePaymentParams) (CreatePaymentRow, error) {
	row := q.db.QueryRow(ctx, createPayment, arg.Amount, arg.StatusID, arg.ProviderID)
	var i CreatePaymentRow
	err := row.Scan(
		&i.Payment.ID,
		&i.Payment.Amount,
		&i.Payment.UpdatedAt,
		&i.Payment.StatusID,
		&i.Payment.ProviderID,
		&i.Payment.OrderID,
		&i.PaymentStatus.ID,
		&i.PaymentStatus.Name,
		&i.PaymentProvider.ID,
		&i.PaymentProvider.Name,
	)
	return i, err
}

const getPaymentByOrderID = `-- name: GetPaymentByOrderID :one
SELECT
  payments.id, payments.amount, payments.updated_at, payments.status_id, payments.provider_id, payments.order_id,
  payment_statuses.id, payment_statuses.name,
  payment_providers.id, payment_providers.name
FROM
  payments
INNER JOIN orders
  ON payments.id = orders.payment_id
INNER JOIN payment_statuses
  ON payments.status_id = payment_statuses.id
INNER JOIN payment_providers
  ON payments.provider_id = payment_providers.id
WHERE
  orders.id = $1
`

type GetPaymentByOrderIDParams struct {
	OrderID int32
}

type GetPaymentByOrderIDRow struct {
	Payment         Payment
	PaymentStatus   PaymentStatus
	PaymentProvider PaymentProvider
}

func (q *Queries) GetPaymentByOrderID(ctx context.Context, arg GetPaymentByOrderIDParams) (GetPaymentByOrderIDRow, error) {
	row := q.db.QueryRow(ctx, getPaymentByOrderID, arg.OrderID)
	var i GetPaymentByOrderIDRow
	err := row.Scan(
		&i.Payment.ID,
		&i.Payment.Amount,
		&i.Payment.UpdatedAt,
		&i.Payment.StatusID,
		&i.Payment.ProviderID,
		&i.Payment.OrderID,
		&i.PaymentStatus.ID,
		&i.PaymentStatus.Name,
		&i.PaymentProvider.ID,
		&i.PaymentProvider.Name,
	)
	return i, err
}

const getPayments = `-- name: GetPayments :many
SELECT
  payments.id, payments.amount, payments.updated_at, payments.status_id, payments.provider_id, payments.order_id,
  payment_statuses.id, payment_statuses.name,
  payment_providers.id, payment_providers.name,
  COUNT(*) OVER() AS current_count,
  COUNT(*) AS total_count
FROM
  payments
INNER JOIN payment_statuses
  ON payments.status_id = payment_statuses.id
INNER JOIN payment_providers
  ON payments.provider_id = payment_providers.id
ORDER BY
  payments.id DESC
OFFSET COALESCE($1::integer, 0)
LIMIT COALESCE($2::integer, 20)
`

type GetPaymentsParams struct {
	Offset pgtype.Int4
	Limit  pgtype.Int4
}

type GetPaymentsRow struct {
	Payment         Payment
	PaymentStatus   PaymentStatus
	PaymentProvider PaymentProvider
	CurrentCount    int64
	TotalCount      int64
}

// NOTE: Filter by between dates? statuses?
func (q *Queries) GetPayments(ctx context.Context, arg GetPaymentsParams) ([]GetPaymentsRow, error) {
	rows, err := q.db.Query(ctx, getPayments, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPaymentsRow
	for rows.Next() {
		var i GetPaymentsRow
		if err := rows.Scan(
			&i.Payment.ID,
			&i.Payment.Amount,
			&i.Payment.UpdatedAt,
			&i.Payment.StatusID,
			&i.Payment.ProviderID,
			&i.Payment.OrderID,
			&i.PaymentStatus.ID,
			&i.PaymentStatus.Name,
			&i.PaymentProvider.ID,
			&i.PaymentProvider.Name,
			&i.CurrentCount,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePaymentStatus = `-- name: UpdatePaymentStatus :execrows
UPDATE payments
SET
  status_id = $1,
  updated_at = NOW()
WHERE
  id = $2::integer
`

type UpdatePaymentStatusParams struct {
	StatusID int32
	ID       int32
}

func (q *Queries) UpdatePaymentStatus(ctx context.Context, arg UpdatePaymentStatusParams) (int64, error) {
	result, err := q.db.Exec(ctx, updatePaymentStatus, arg.StatusID, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
