// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: attribute.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countAttributeValues = `-- name: CountAttributeValues :one
SELECT
  COUNT(*) AS count
FROM
  attribute_values
WHERE
  CASE
    WHEN cardinality($1::uuid[]) = 0 THEN TRUE
    ELSE id = ANY ($1::uuid[])
  END
  AND CASE
    WHEN $2::uuid = '00000000-0000-0000-0000-000000000000'::uuid THEN TRUE
    ELSE attribute_id = $2::uuid
  END
  AND CASE
    WHEN cardinality($3::uuid[]) = 0 THEN TRUE
     ELSE attribute_id = ANY ($3::uuid[])
  END
  AND CASE
    WHEN $4::text = 'exclude' THEN deleted_at IS NULL
    WHEN $4::text = 'only' THEN deleted_at IS NOT NULL
    WHEN $4::text = 'all' THEN TRUE
    ELSE deleted_at IS NULL
  END
`

type CountAttributeValuesParams struct {
	IDs          []uuid.UUID
	AttributeID  uuid.UUID
	AttributeIDs []uuid.UUID
	Deleted      string
}

func (q *Queries) CountAttributeValues(ctx context.Context, arg CountAttributeValuesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAttributeValues,
		arg.IDs,
		arg.AttributeID,
		arg.AttributeIDs,
		arg.Deleted,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAttributes = `-- name: CountAttributes :one
SELECT
  COUNT(*) AS count
FROM
  attributes
WHERE
  CASE
    WHEN cardinality($1::uuid[]) = 0 THEN TRUE
    ELSE id = ANY ($1::uuid[])
  END
  AND CASE
    WHEN $2::text = 'exclude' THEN deleted_at IS NULL
    WHEN $2::text = 'only' THEN deleted_at IS NOT NULL
    WHEN $2::text = 'all' THEN TRUE
    ELSE deleted_at IS NULL
  END
`

type CountAttributesParams struct {
	IDs     []uuid.UUID
	Deleted string
}

func (q *Queries) CountAttributes(ctx context.Context, arg CountAttributesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAttributes, arg.IDs, arg.Deleted)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createTempTableAttributeValues = `-- name: CreateTempTableAttributeValues :exec
CREATE TEMPORARY TABLE temp_attribute_values (
  id UUID PRIMARY KEY,
  attribute_id UUID NOT NULL,
  value TEXT NOT NULL,
  deleted_at TIMESTAMPTZ
) ON COMMIT DROP
`

func (q *Queries) CreateTempTableAttributeValues(ctx context.Context) error {
	_, err := q.db.Exec(ctx, createTempTableAttributeValues)
	return err
}

const getAttribute = `-- name: GetAttribute :one
SELECT
  id, code, name, deleted_at
FROM
  attributes
WHERE
  id = $1::uuid
  AND CASE
    WHEN $2::text = 'exclude' THEN deleted_at IS NULL
    WHEN $2::text = 'only' THEN deleted_at IS NOT NULL
    WHEN $2::text = 'all' THEN TRUE
    ELSE deleted_at IS NULL
  END
`

type GetAttributeParams struct {
	ID      uuid.UUID
	Deleted string
}

func (q *Queries) GetAttribute(ctx context.Context, arg GetAttributeParams) (Attribute, error) {
	row := q.db.QueryRow(ctx, getAttribute, arg.ID, arg.Deleted)
	var i Attribute
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.DeletedAt,
	)
	return i, err
}

type InsertTempTableAttributeValuesParams struct {
	ID          uuid.UUID
	AttributeID uuid.UUID
	Value       string
	DeletedAt   pgtype.Timestamptz
}

const listAttributeByAttributeValues = `-- name: ListAttributeByAttributeValues :many
SELECT
  attributes.id, attributes.code, attributes.name, attributes.deleted_at
FROM
  attributes
JOIN
  attribute_values ON attribute_values.attribute_id = attributes.id
WHERE
  CASE
    WHEN cardinality($1::uuid[]) = 0 THEN TRUE
    ELSE attribute_values.id = ANY ($1::uuid[])
  END
  AND CASE
    WHEN $2::text = 'exclude' THEN attributes.deleted_at IS NULL
    WHEN $2::text = 'only' THEN attributes.deleted_at IS NOT NULL
    WHEN $2::text = 'all' THEN TRUE
    ELSE attributes.deleted_at IS NULL
  END
GROUP BY
  attributes.id
ORDER BY
  attributes.id ASC
`

type ListAttributeByAttributeValuesParams struct {
	AttributeValueIDs []uuid.UUID
	Deleted           string
}

func (q *Queries) ListAttributeByAttributeValues(ctx context.Context, arg ListAttributeByAttributeValuesParams) ([]Attribute, error) {
	rows, err := q.db.Query(ctx, listAttributeByAttributeValues, arg.AttributeValueIDs, arg.Deleted)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Attribute
	for rows.Next() {
		var i Attribute
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAttributeValues = `-- name: ListAttributeValues :many
SELECT
  id, attribute_id, value, deleted_at
FROM
  attribute_values
WHERE
  CASE
    WHEN cardinality($1::uuid[]) = 0 THEN TRUE
    ELSE id = ANY ($1::uuid[])
  END
  AND CASE
    WHEN $2::uuid = '00000000-0000-0000-0000-000000000000'::uuid THEN TRUE
    ELSE attribute_id = $2::uuid
  END
  AND CASE
    WHEN cardinality($3::uuid[]) = 0 THEN TRUE
     ELSE attribute_id = ANY ($3::uuid[])
  END
  AND CASE
    WHEN $4::text = '' THEN TRUE
    ELSE value ||| ($4::text)
  END
  AND CASE
    WHEN $5::text = 'exclude' THEN deleted_at IS NULL
    WHEN $5::text = 'only' THEN deleted_at IS NOT NULL
    WHEN $5::text = 'all' THEN TRUE
    ELSE deleted_at IS NULL
  END
ORDER BY
  CASE WHEN $4::text <> '' THEN pdb.score(id) END DESC,
  id ASC
OFFSET $6::integer
LIMIT NULLIF($7::integer, 0)
`

type ListAttributeValuesParams struct {
	IDs          []uuid.UUID
	AttributeID  uuid.UUID
	AttributeIDs []uuid.UUID
	Search       string
	Deleted      string
	Offset       int32
	Limit        int32
}

func (q *Queries) ListAttributeValues(ctx context.Context, arg ListAttributeValuesParams) ([]AttributeValue, error) {
	rows, err := q.db.Query(ctx, listAttributeValues,
		arg.IDs,
		arg.AttributeID,
		arg.AttributeIDs,
		arg.Search,
		arg.Deleted,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AttributeValue
	for rows.Next() {
		var i AttributeValue
		if err := rows.Scan(
			&i.ID,
			&i.AttributeID,
			&i.Value,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAttributes = `-- name: ListAttributes :many
SELECT
  attributes.id, attributes.code, attributes.name, attributes.deleted_at
FROM
  attributes
LEFT JOIN (
  SELECT
    id,
    attribute_id
  FROM
    attribute_values
  WHERE
    CASE
      WHEN cardinality($1::uuid[]) = 0 THEN TRUE
      ELSE attribute_values.id = ANY ($1::uuid[])
    END
) AS av ON attributes.id = av.attribute_id
WHERE
  CASE
    WHEN cardinality($2::uuid[]) = 0 THEN TRUE
    ELSE attributes.id = ANY ($2::uuid[])
  END
  AND CASE
    WHEN $3::text = '' THEN TRUE
    ELSE
      code ||| ($3::text)
      OR name ||| ($3::text)
  END
  AND CASE
    WHEN cardinality($1::uuid[]) = 0 THEN TRUE
    ELSE av.id IS NOT NULL
  END
  AND CASE
    WHEN $4::text = 'exclude' THEN deleted_at IS NULL
    WHEN $4::text = 'only' THEN deleted_at IS NOT NULL
    WHEN $4::text = 'all' THEN TRUE
    ELSE deleted_at IS NULL
  END
ORDER BY
  CASE WHEN $3::text <> '' THEN pdb.score(attributes.id) END DESC,
  attributes.id ASC
OFFSET $5::integer
LIMIT NULLIF($6::integer, 0)
`

type ListAttributesParams struct {
	AttributeValueIDs []uuid.UUID
	IDs               []uuid.UUID
	Search            string
	Deleted           string
	Offset            int32
	Limit             int32
}

func (q *Queries) ListAttributes(ctx context.Context, arg ListAttributesParams) ([]Attribute, error) {
	rows, err := q.db.Query(ctx, listAttributes,
		arg.AttributeValueIDs,
		arg.IDs,
		arg.Search,
		arg.Deleted,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Attribute
	for rows.Next() {
		var i Attribute
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const mergeAttributeValuesFromTemp = `-- name: MergeAttributeValuesFromTemp :exec
MERGE INTO attribute_values AS target
USING temp_attribute_values AS source
  ON target.id = source.id
WHEN MATCHED THEN
  UPDATE SET
    attribute_id = source.attribute_id,
    value = source.value,
    deleted_at = COALESCE(NULLIF(source.deleted_at, '0001-01-01T00:00:00Z'::timestamptz), target.deleted_at)
WHEN NOT MATCHED THEN
  INSERT (
    id,
    attribute_id,
    value,
    deleted_at
  )
  VALUES (
    source.id,
    source.attribute_id,
    source.value,
    NULLIF(source.deleted_at, '0001-01-01T00:00:00Z'::timestamptz)
  )
WHEN NOT MATCHED BY SOURCE
  AND target.attribute_id IN (SELECT DISTINCT attribute_id FROM temp_attribute_values) THEN
  DELETE
`

func (q *Queries) MergeAttributeValuesFromTemp(ctx context.Context) error {
	_, err := q.db.Exec(ctx, mergeAttributeValuesFromTemp)
	return err
}

const upsertAttribute = `-- name: UpsertAttribute :exec
INSERT INTO attributes (
  id,
  code,
  name,
  deleted_at
)
VALUES (
  $1,
  $2,
  $3,
  NULLIF($4::timestamptz, '0001-01-01T00:00:00Z'::timestamptz)
)
ON CONFLICT (id) DO UPDATE SET
  code = EXCLUDED.code,
  name = EXCLUDED.name,
  deleted_at = COALESCE(EXCLUDED.deleted_at, attributes.deleted_at)
`

type UpsertAttributeParams struct {
	ID        uuid.UUID
	Code      string
	Name      string
	DeletedAt pgtype.Timestamptz
}

func (q *Queries) UpsertAttribute(ctx context.Context, arg UpsertAttributeParams) error {
	_, err := q.db.Exec(ctx, upsertAttribute,
		arg.ID,
		arg.Code,
		arg.Name,
		arg.DeletedAt,
	)
	return err
}
