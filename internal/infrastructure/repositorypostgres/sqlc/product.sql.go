// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: product.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countProducts = `-- name: CountProducts :one
SELECT
  COUNT(*) AS count
FROM
  products
WHERE
  CASE
    WHEN $1::uuid IS NULL THEN TRUE
    ELSE products.id = $1::uuid
  END
  AND CASE
    WHEN $2::uuid[] IS NULL THEN TRUE
    WHEN cardinality($2::uuid[]) = 0 THEN TRUE
    ELSE products.id = ANY ($2::uuid[])
  END
  AND CASE
    WHEN $3::decimal IS NULL THEN TRUE
    ELSE products.price >= $3::decimal
  END
  AND CASE
    WHEN $4::decimal IS NULL THEN TRUE
    ELSE products.price <= $4::decimal
  END
  AND CASE
    WHEN $5::real IS NULL THEN TRUE
    ELSE products.rating >= $5::real
  END
  AND CASE
    WHEN $6::uuid[] IS NULL THEN TRUE
    WHEN cardinality($6::uuid[]) = 0 THEN TRUE
    ELSE products.category_id = ANY ($6::uuid[])
  END
  AND CASE
    WHEN $7::text = 'exclude' THEN products.deleted_at IS NULL
    WHEN $7::text = 'only' THEN products.deleted_at IS NOT NULL
    WHEN $7::text = 'all' THEN TRUE
    ELSE products.deleted_at IS NULL
  END
`

type CountProductsParams struct {
	ID          pgtype.UUID
	IDs         []uuid.UUID
	MinPrice    pgtype.Numeric
	MaxPrice    pgtype.Numeric
	Rating      *float32
	CategoryIDs []uuid.UUID
	Deleted     string
}

func (q *Queries) CountProducts(ctx context.Context, arg CountProductsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countProducts,
		arg.ID,
		arg.IDs,
		arg.MinPrice,
		arg.MaxPrice,
		arg.Rating,
		arg.CategoryIDs,
		arg.Deleted,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createTempTableOptionValuesProductVariants = `-- name: CreateTempTableOptionValuesProductVariants :exec
CREATE TEMPORARY TABLE temp_option_values_product_variants (
  product_variant_id UUID NOT NULL,
  option_value_id UUID NOT NULL,
  PRIMARY KEY (product_variant_id, option_value_id)
) ON COMMIT DROP
`

func (q *Queries) CreateTempTableOptionValuesProductVariants(ctx context.Context) error {
	_, err := q.db.Exec(ctx, createTempTableOptionValuesProductVariants)
	return err
}

const createTempTableProductImages = `-- name: CreateTempTableProductImages :exec
CREATE TEMPORARY TABLE temp_product_images (
  id UUID PRIMARY KEY,
  url TEXT NOT NULL,
  "order" INTEGER NOT NULL,
  product_id UUID NOT NULL,
  product_variant_id UUID,
  created_at TIMESTAMPTZ NOT NULL,
  deleted_at TIMESTAMPTZ
) ON COMMIT DROP
`

func (q *Queries) CreateTempTableProductImages(ctx context.Context) error {
	_, err := q.db.Exec(ctx, createTempTableProductImages)
	return err
}

const createTempTableProductVariants = `-- name: CreateTempTableProductVariants :exec
CREATE TEMPORARY TABLE temp_product_variants (
  id UUID PRIMARY KEY,
  sku TEXT NOT NULL,
  price DECIMAL(12, 0) NOT NULL,
  quantity INTEGER NOT NULL,
  purchase_count INTEGER NOT NULL,
  product_id UUID NOT NULL,
  created_at TIMESTAMPTZ NOT NULL,
  updated_at TIMESTAMPTZ NOT NULL,
  deleted_at TIMESTAMPTZ
) ON COMMIT DROP
`

func (q *Queries) CreateTempTableProductVariants(ctx context.Context) error {
	_, err := q.db.Exec(ctx, createTempTableProductVariants)
	return err
}

const createTempTableProductsAttributeValues = `-- name: CreateTempTableProductsAttributeValues :exec
CREATE TEMPORARY TABLE temp_products_attribute_values (
  product_id UUID NOT NULL,
  attribute_value_id UUID NOT NULL,
  PRIMARY KEY (product_id, attribute_value_id)
) ON COMMIT DROP
`

func (q *Queries) CreateTempTableProductsAttributeValues(ctx context.Context) error {
	_, err := q.db.Exec(ctx, createTempTableProductsAttributeValues)
	return err
}

const getProduct = `-- name: GetProduct :one
SELECT
  id, name, description, price, views_count, total_purchase, rating, trending_score, category_id, created_at, updated_at, deleted_at
FROM
  products
WHERE
  products.id = $1
  AND CASE
    WHEN $2::text = 'exclude' THEN deleted_at IS NULL
    WHEN $2::text = 'only' THEN deleted_at IS NOT NULL
    WHEN $2::text = 'all' THEN TRUE
    ELSE deleted_at IS NULL
  END
`

type GetProductParams struct {
	ID      uuid.UUID
	Deleted string
}

func (q *Queries) GetProduct(ctx context.Context, arg GetProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, getProduct, arg.ID, arg.Deleted)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.ViewsCount,
		&i.TotalPurchase,
		&i.Rating,
		&i.TrendingScore,
		&i.CategoryID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getProductImage = `-- name: GetProductImage :one
SELECT
  id, url, "order", created_at, deleted_at, product_id, product_variant_id
FROM
  product_images
WHERE
  id = $1
`

type GetProductImageParams struct {
	ID uuid.UUID
}

func (q *Queries) GetProductImage(ctx context.Context, arg GetProductImageParams) (ProductImage, error) {
	row := q.db.QueryRow(ctx, getProductImage, arg.ID)
	var i ProductImage
	err := row.Scan(
		&i.ID,
		&i.URL,
		&i.Order,
		&i.CreatedAt,
		&i.DeletedAt,
		&i.ProductID,
		&i.ProductVariantID,
	)
	return i, err
}

const getProductVariant = `-- name: GetProductVariant :one
SELECT
  id, sku, price, quantity, purchase_count, product_id, created_at, updated_at, deleted_at
FROM
  product_variants
WHERE
  id = $1
  AND CASE
    WHEN $2::text = 'exclude' THEN deleted_at IS NULL
    WHEN $2::text = 'only' THEN deleted_at IS NOT NULL
    WHEN $2::text = 'all' THEN TRUE
    ELSE deleted_at IS NULL
  END
`

type GetProductVariantParams struct {
	ID      uuid.UUID
	Deleted string
}

func (q *Queries) GetProductVariant(ctx context.Context, arg GetProductVariantParams) (ProductVariant, error) {
	row := q.db.QueryRow(ctx, getProductVariant, arg.ID, arg.Deleted)
	var i ProductVariant
	err := row.Scan(
		&i.ID,
		&i.SKU,
		&i.Price,
		&i.Quantity,
		&i.PurchaseCount,
		&i.ProductID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

type InsertTempTableOptionValuesProductVariantsParams struct {
	ProductVariantID uuid.UUID
	OptionValueID    uuid.UUID
}

type InsertTempTableProductImagesParams struct {
	ID               uuid.UUID
	URL              string
	Order            int32
	ProductID        uuid.UUID
	ProductVariantID pgtype.UUID
	CreatedAt        pgtype.Timestamptz
	DeletedAt        pgtype.Timestamptz
}

type InsertTempTableProductVariantsParams struct {
	ID            uuid.UUID
	SKU           string
	Price         pgtype.Numeric
	Quantity      int32
	PurchaseCount int32
	ProductID     uuid.UUID
	CreatedAt     pgtype.Timestamptz
	UpdatedAt     pgtype.Timestamptz
	DeletedAt     pgtype.Timestamptz
}

type InsertTempTableProductsAttributeValuesParams struct {
	ProductID        uuid.UUID
	AttributeValueID uuid.UUID
}

const listProductImages = `-- name: ListProductImages :many
SELECT
  id, url, "order", created_at, deleted_at, product_id, product_variant_id
FROM
  product_images
WHERE
  CASE
    WHEN $1::uuid[] IS NULL THEN TRUE
    WHEN cardinality($1::uuid[]) = 0 THEN TRUE
    ELSE id = ANY ($1::uuid[])
  END
  AND CASE
    WHEN $2::uuid[] IS NULL THEN TRUE
    WHEN cardinality($2::uuid[]) = 0 THEN TRUE
    ELSE product_variant_id = ANY ($2::uuid[])
  END
  AND CASE
    WHEN $3::uuid[] IS NULL THEN TRUE
    WHEN cardinality($3::uuid[]) = 0 THEN TRUE
    ELSE product_id = ANY ($3::uuid[])
  END
ORDER BY
  id ASC
`

type ListProductImagesParams struct {
	IDs               []uuid.UUID
	ProductVariantIDs []uuid.UUID
	ProductIDs        []uuid.UUID
}

func (q *Queries) ListProductImages(ctx context.Context, arg ListProductImagesParams) ([]ProductImage, error) {
	rows, err := q.db.Query(ctx, listProductImages, arg.IDs, arg.ProductVariantIDs, arg.ProductIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductImage
	for rows.Next() {
		var i ProductImage
		if err := rows.Scan(
			&i.ID,
			&i.URL,
			&i.Order,
			&i.CreatedAt,
			&i.DeletedAt,
			&i.ProductID,
			&i.ProductVariantID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductVariants = `-- name: ListProductVariants :many
SELECT
  id, sku, price, quantity, purchase_count, product_id, created_at, updated_at, deleted_at
FROM
  product_variants
WHERE
  CASE
    WHEN $1::uuid IS NULL THEN TRUE
    ELSE id = $1::uuid
  END
  AND CASE
    WHEN $2::text IS NULL THEN TRUE
    ELSE sku = $2::text
  END
  AND CASE
    WHEN $3::uuid[] IS NULL THEN TRUE
    WHEN cardinality($3::uuid[]) = 0 THEN TRUE
    ELSE id = ANY ($3::uuid[])
  END
  AND CASE
    WHEN $4::uuid IS NULL THEN TRUE
    ELSE product_id = $4::uuid
  END
  AND CASE
    WHEN $5::uuid[] IS NULL THEN TRUE
    WHEN cardinality($5::uuid[]) = 0 THEN TRUE
    ELSE product_id = ANY ($5::uuid[])
  END
  AND CASE
    WHEN $6::text = 'exclude' THEN deleted_at IS NULL
    WHEN $6::text = 'only' THEN deleted_at IS NOT NULL
    WHEN $6::text = 'all' THEN TRUE
    ELSE deleted_at IS NULL
  END
ORDER BY
  id
OFFSET $7::integer
LIMIT NULLIF($8::integer, 0)
`

type ListProductVariantsParams struct {
	ID         pgtype.UUID
	SKU        *string
	IDs        []uuid.UUID
	ProductID  pgtype.UUID
	ProductIDs []uuid.UUID
	Deleted    string
	Offset     int32
	Limit      int32
}

func (q *Queries) ListProductVariants(ctx context.Context, arg ListProductVariantsParams) ([]ProductVariant, error) {
	rows, err := q.db.Query(ctx, listProductVariants,
		arg.ID,
		arg.SKU,
		arg.IDs,
		arg.ProductID,
		arg.ProductIDs,
		arg.Deleted,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductVariant
	for rows.Next() {
		var i ProductVariant
		if err := rows.Scan(
			&i.ID,
			&i.SKU,
			&i.Price,
			&i.Quantity,
			&i.PurchaseCount,
			&i.ProductID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProducts = `-- name: ListProducts :many
SELECT
  products.id, products.name, products.description, products.price, products.views_count, products.total_purchase, products.rating, products.trending_score, products.category_id, products.created_at, products.updated_at, products.deleted_at
FROM
  products
LEFT JOIN (
  SELECT
    products.id,
    pdb.score(products.id) AS category_score
  FROM products
  INNER JOIN categories
    ON products.category_id = categories.id
  WHERE
    CASE WHEN $1::text IS NULL THEN TRUE
      ELSE (
        categories.name ||| $1::text
        AND categories.deleted_at IS NULL
      )
    END
) AS category_scores
  ON products.id = category_scores.id
WHERE
  CASE
    WHEN $2::uuid IS NULL THEN TRUE
    ELSE products.id = $2::uuid
  END
  AND CASE
    WHEN $3::uuid[] IS NULL THEN TRUE
    WHEN cardinality($3::uuid[]) = 0 THEN TRUE
    ELSE products.id = ANY ($3::uuid[])
  END
  AND CASE
    WHEN $1::text IS NULL THEN TRUE
    ELSE products.name ||| $1::text
  END
  AND CASE
    WHEN $4::decimal IS NULL THEN TRUE
    ELSE products.price >= $4::decimal
  END
  AND CASE
    WHEN $5::decimal IS NULL THEN TRUE
    ELSE products.price <= $5::decimal
  END
  AND CASE
    WHEN $6::real IS NULL THEN TRUE
    ELSE products.rating >= $6::real
  END
  AND CASE
    WHEN $7::uuid[] IS NULL THEN TRUE
    WHEN cardinality($7::uuid[]) = 0 THEN TRUE
    ELSE products.category_id = ANY ($7::uuid[])
  END
  AND CASE
    WHEN $8::text = 'exclude' THEN products.deleted_at IS NULL
    WHEN $8::text = 'only' THEN products.deleted_at IS NOT NULL
    WHEN $8::text = 'all' THEN TRUE
    ELSE products.deleted_at IS NULL
  END
ORDER BY
  CASE WHEN
    $1 IS NOT NULL THEN pdb.score(products.id) + category_scores.category_score + products.trending_score
  END DESC,
  CASE WHEN
    $9::text = 'asc' THEN products.rating
  END ASC,
  CASE WHEN
    $9::text = 'desc' THEN products.rating
  END DESC,
  CASE WHEN
   $10::text = 'asc' THEN products.price
  END ASC,
  CASE WHEN
   $10::text = 'desc' THEN products.price
  END DESC
OFFSET $11::integer
LIMIT NULLIF($12::integer, 0)
`

type ListProductsParams struct {
	Search      *string
	ID          pgtype.UUID
	IDs         []uuid.UUID
	MinPrice    pgtype.Numeric
	MaxPrice    pgtype.Numeric
	Rating      *float32
	CategoryIDs []uuid.UUID
	Deleted     string
	SortRating  *string
	SortPrice   *string
	Offset      int32
	Limit       int32
}

// This is used for list, search (with filter, order), suggest
func (q *Queries) ListProducts(ctx context.Context, arg ListProductsParams) ([]Product, error) {
	rows, err := q.db.Query(ctx, listProducts,
		arg.Search,
		arg.ID,
		arg.IDs,
		arg.MinPrice,
		arg.MaxPrice,
		arg.Rating,
		arg.CategoryIDs,
		arg.Deleted,
		arg.SortRating,
		arg.SortPrice,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.ViewsCount,
			&i.TotalPurchase,
			&i.Rating,
			&i.TrendingScore,
			&i.CategoryID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductsAttributeValues = `-- name: ListProductsAttributeValues :many
SELECT
  product_id, attribute_value_id
FROM
  products_attribute_values
WHERE
  CASE
    WHEN $1::uuid IS NULL THEN TRUE
    ELSE product_id = $1::uuid
  END
  AND CASE
    WHEN $2::uuid[] IS NULL THEN TRUE
    WHEN cardinality($2::uuid[]) = 0 THEN TRUE
    ELSE product_id = ANY ($2::uuid[])
  END
  AND CASE
    WHEN $3::uuid[] IS NULL THEN TRUE
    WHEN cardinality($3::uuid[]) = 0 THEN TRUE
    ELSE attribute_value_id = ANY ($3::uuid[])
  END
ORDER BY
  product_id ASC,
  attribute_value_id ASC
`

type ListProductsAttributeValuesParams struct {
	ProductID         pgtype.UUID
	ProductIDs        []uuid.UUID
	AttributeValueIDs []uuid.UUID
}

func (q *Queries) ListProductsAttributeValues(ctx context.Context, arg ListProductsAttributeValuesParams) ([]ProductsAttributeValue, error) {
	rows, err := q.db.Query(ctx, listProductsAttributeValues, arg.ProductID, arg.ProductIDs, arg.AttributeValueIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductsAttributeValue
	for rows.Next() {
		var i ProductsAttributeValue
		if err := rows.Scan(&i.ProductID, &i.AttributeValueID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const mergeOptionValuesProductVariantsFromTemp = `-- name: MergeOptionValuesProductVariantsFromTemp :exec
MERGE INTO option_values_product_variants AS target
USING temp_option_values_product_variants AS source
  ON target.option_value_id = source.option_value_id
WHEN NOT MATCHED THEN
  INSERT (
    product_variant_id,
    option_value_id
  )
  VALUES (
    source.product_variant_id,
    source.option_value_id
  )
WHEN NOT MATCHED BY SOURCE
  AND target.option_value_id = ANY (SELECT id FROM temp_option_values) THEN
  DELETE
`

func (q *Queries) MergeOptionValuesProductVariantsFromTemp(ctx context.Context) error {
	_, err := q.db.Exec(ctx, mergeOptionValuesProductVariantsFromTemp)
	return err
}

const mergeProductImagesFromTemp = `-- name: MergeProductImagesFromTemp :exec
MERGE INTO product_images AS target
USING temp_product_images AS source
  ON target.id = source.id
WHEN MATCHED THEN
  UPDATE SET
    url = source.url,
    "order" = source."order",
    product_id = source.product_id,
    product_variant_id = source.product_variant_id,
    created_at = source.created_at,
    deleted_at = source.deleted_at
WHEN NOT MATCHED THEN
  INSERT (
    id,
    url,
    "order",
    product_id,
    product_variant_id,
    created_at,
    deleted_at
  )
  VALUES (
    source.id,
    source.url,
    source."order",
    source.product_id,
    source.product_variant_id,
    source.created_at,
    source.deleted_at
  )
WHEN NOT MATCHED BY SOURCE
  AND target.product_id = ANY (SELECT DISTINCT product_id FROM temp_product_images) THEN
  DELETE
`

func (q *Queries) MergeProductImagesFromTemp(ctx context.Context) error {
	_, err := q.db.Exec(ctx, mergeProductImagesFromTemp)
	return err
}

const mergeProductVariantsFromTemp = `-- name: MergeProductVariantsFromTemp :exec
MERGE INTO product_variants AS target
USING temp_product_variants AS source
  ON target.id = source.id
WHEN MATCHED THEN
  UPDATE SET
    sku = source.sku,
    price = source.price,
    quantity = source.quantity,
    purchase_count = source.purchase_count,
    product_id = source.product_id,
    created_at = source.created_at,
    updated_at = source.updated_at,
    deleted_at = source.deleted_at
WHEN NOT MATCHED THEN
  INSERT (
    id,
    sku,
    price,
    quantity,
    purchase_count,
    product_id,
    created_at,
    updated_at,
    deleted_at
  )
  VALUES (
    source.id,
    source.sku,
    source.price,
    source.quantity,
    source.purchase_count,
    source.product_id,
    source.created_at,
    source.updated_at,
    source.deleted_at
  )
WHEN NOT MATCHED BY SOURCE
  AND target.product_id = ANY (SELECT DISTINCT id FROM temp_product_variants) THEN
  DELETE
`

func (q *Queries) MergeProductVariantsFromTemp(ctx context.Context) error {
	_, err := q.db.Exec(ctx, mergeProductVariantsFromTemp)
	return err
}

const mergeProductsAttributeValuesFromTemp = `-- name: MergeProductsAttributeValuesFromTemp :exec
MERGE INTO products_attribute_values AS target
USING temp_products_attribute_values AS source
  ON target.product_id = source.product_id
    AND target.attribute_value_id = source.attribute_value_id
WHEN NOT MATCHED THEN
  INSERT (
    product_id,
    attribute_value_id
  )
  VALUES (
    source.product_id,
    source.attribute_value_id
  )
WHEN NOT MATCHED BY SOURCE
  AND target.product_id = ANY (SELECT DISTINCT product_id FROM temp_products_attribute_values) THEN
  DELETE
`

func (q *Queries) MergeProductsAttributeValuesFromTemp(ctx context.Context) error {
	_, err := q.db.Exec(ctx, mergeProductsAttributeValuesFromTemp)
	return err
}

const upsertProduct = `-- name: UpsertProduct :exec
INSERT INTO products (
  id,
  name,
  description,
  price,
  views_count,
  total_purchase,
  rating,
  trending_score,
  category_id,
  created_at,
  updated_at,
  deleted_at
)
VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  $8,
  $9,
  $10,
  $11,
  $12
)
ON CONFLICT (id) DO UPDATE SET
  name = EXCLUDED.name,
  description = EXCLUDED.description,
  price = EXCLUDED.price,
  views_count = EXCLUDED.views_count,
  total_purchase = EXCLUDED.total_purchase,
  rating = EXCLUDED.rating,
  trending_score = EXCLUDED.trending_score,
  category_id = EXCLUDED.category_id,
  created_at = EXCLUDED.created_at,
  updated_at = EXCLUDED.updated_at,
  deleted_at = EXCLUDED.deleted_at
`

type UpsertProductParams struct {
	ID            uuid.UUID
	Name          string
	Description   string
	Price         pgtype.Numeric
	ViewsCount    int32
	TotalPurchase int32
	Rating        float32
	TrendingScore float32
	CategoryID    uuid.UUID
	CreatedAt     pgtype.Timestamptz
	UpdatedAt     pgtype.Timestamptz
	DeletedAt     pgtype.Timestamptz
}

func (q *Queries) UpsertProduct(ctx context.Context, arg UpsertProductParams) error {
	_, err := q.db.Exec(ctx, upsertProduct,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Price,
		arg.ViewsCount,
		arg.TotalPurchase,
		arg.Rating,
		arg.TrendingScore,
		arg.CategoryID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.DeletedAt,
	)
	return err
}
